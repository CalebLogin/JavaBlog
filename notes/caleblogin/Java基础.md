# Java基础
<!--ts-->
- [Java基础](#java基础)
  - [为什么说java是编译和解释并存？](#为什么说java是编译和解释并存)
  - [== 和 equal的区别？](#-和-equal的区别)
  - [为什么java只有值传递没有引用传递？](#为什么java只有值传递没有引用传递)
  - [深拷贝和浅拷贝](#深拷贝和浅拷贝)
  - [重载和重写的区别？](#重载和重写的区别)
  - [四个修饰符](#四个修饰符)
  - [String、StringBuffer和StringBuilder的区别](#stringstringbuffer和stringbuilder的区别)
    - [String不可变的原因、好处](#string不可变的原因好处)
    - [StringBuilder、StringBuffer](#stringbuilderstringbuffer)
  - [new String在内部存储结构发生什么？](#new-string在内部存储结构发生什么)
  - [abstract 和 interface](#abstract-和-interface)
  - [你知道的内部类有哪些java当中的？](#你知道的内部类有哪些java当中的)
  - [静态内部类和内部类有什么区别？](#静态内部类和内部类有什么区别)
    - [普通内部类](#普通内部类)
    - [静态内部类](#静态内部类)
    - [初始化的时候静态内部类什么时候初始化？](#初始化的时候静态内部类什么时候初始化)
    - [为什么静态方法调用非静态方法是错误的？](#为什么静态方法调用非静态方法是错误的)
  - [面向对象和面向过程的区别](#面向对象和面向过程的区别)
  - [面向对象的三大特征？](#面向对象的三大特征)
  - [异常](#异常)
  - [try catch finally](#try-catch-finally)
  - [Object有什么方法，什么时候用到hashcode方法?](#object有什么方法什么时候用到hashcode方法)
  - [反射](#反射)
  - [cglib反射和jdk反射的区别](#cglib反射和jdk反射的区别)
  - [泛型](#泛型)
  - [SPI机制](#spi机制)
  - [什么是序列化，什么是反序列化](#什么是序列化什么是反序列化)
  - [java中IO流分为几种？](#java中io流分为几种)
  - [既然有了字节流为什么还要字符流？](#既然有了字节流为什么还要字符流)
  - [socket套接字](#socket套接字)
  - [常用注解说一下](#常用注解说一下)
  - [面向对象编程的五大原则](#面向对象编程的五大原则)
  - [设计模式](#设计模式)
    - [构建型模式](#构建型模式)
      - [工厂方法模式](#工厂方法模式)
        - [简单工厂模式](#简单工厂模式)
        - [工厂方法模式](#工厂方法模式-1)
        - [抽象工厂模式](#抽象工厂模式)
      - [单例模式](#单例模式)
      - [建造型模式](#建造型模式)
      - [原型模式](#原型模式)
    - [结构型模式](#结构型模式)
      - [适配器模式](#适配器模式)
      - [桥接模式](#桥接模式)
      - [组合模式](#组合模式)
      - [装饰器模式](#装饰器模式)
      - [代理模式](#代理模式)
    - [行为型模式](#行为型模式)
      - [责任链模式](#责任链模式)
      - [观察者模式](#观察者模式)
      - [模板方法模式](#模板方法模式)
  - [bitset、bitmap](#bitsetbitmap)
    - [bitmap算法](#bitmap算法)
    - [bitset](#bitset)
    - [布隆过滤器](#布隆过滤器)
    - [怎么解决hash冲突](#怎么解决hash冲突)
  - [tomcat出问题了，怎么通过日志排查](#tomcat出问题了怎么通过日志排查)
  - [tomcat线程安全问题](#tomcat线程安全问题)
  - [红黑树](#红黑树)

<!-- Added by: hanzhigang, at: 2021年 8月20日 星期五 14时38分07秒 CST -->

<!--te-->
## 为什么说java是编译和解释并存？
编译是指编译器是针对特定的操作系统将源码一次性翻译成可被平台执行的机器码。解释是指解释器对源码逐行解释成特定平台的机器码并立即执行。
java要先经过编译再经过解释两个步骤，由java编写的程序首先经过编译步骤，生成字节码文件，这种字节码文件必须由java解释器来解释执行。
## == 和 equal的区别？
== 对于普通类型来说是进行值的比较，对于引用类型来说是进行地址的比较。
equals 不能用于普通类型的比较，只能用来判断两个对象是否相等。对于没有重写equal的类，这时候equal和==的作用是相同的，比较的是两个对象的地址。对于覆盖了equal的类，比较的是equal方法中的，覆盖了equal方法，必须覆盖hashcode，hashcode的作用是获取哈希码，这个hash码的作用是确定该对象在哈希表中的位置，在使用hashset时，使用hashcode来确定对象加入的位置，如果发现有hashcode相同的对象，再调用equals来判断两个对象是否相等。如果两个对象相等，那么他们的hashcode一定是相等的。两个对象相等，对两个对象分别调用equals分别返回true。但是两个对象hashcode相等，他们也不一定是相等的。因此equals被覆盖过，hashcode也必须被覆盖。如果没有覆盖hashcode，这两个对象是不可能相等的，即使两个对象指向了相同的数据。
## 为什么java只有值传递没有引用传递？
值传递：方法调用得到的是调用者提供的值，引用传递：方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。java总是按值调用，方法得到的是所有参数值的一个拷贝。
## 深拷贝和浅拷贝
浅拷贝：对于基本数据类型进行值传递，对于引用数据类型进行引用传递般的拷贝。
深拷贝：对于基本数据类型进行值传递，对于引用数据类型，创建一个新对象，并复制其内容。
## 重载和重写的区别？
重载就是同一个方法能够根据输入数据的不同，做出不同的处理。
重写是当子类继承父类的的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类的方法。方法的重写要遵循两同两小一大。两同：方法名相同，形参列表相同。两小：子类的返回类型要比父类的返回类型更小或相等。子类方法声明抛出的异常要比父类方法声明抛出的异常更小或相等。一大：子类方法的访问权限要比父类方法的访问权限更大或相等。
## 四个修饰符
1. public 
2. private
3. protected：包内调用和子类调用
4. 默认：包内调用
## String、StringBuffer和StringBuilder的区别
### String不可变的原因、好处
原因：Java9之后使用byte数组存储字符串，被声明为final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。
- 好处：
1. 可以缓存hash值：String的hash值被经常使用（例如用作Hashmap的key），保证不变hash值不会改变，只需要计算一次。
2. String Pool：String对象创建过，会到StringPool中引用。（StringPoll：创建字符串时，如果存在池中，则返回现有字符串的引用，不创建新对象）。
3. 安全：String经常作为参数，不可改变保证参数不便。（例如网络连接参数）
4. 线程安全：不可变，天生线程安全，不用考虑同步问题。
### StringBuilder、StringBuffer
StringBuffer是线程安全的，类中的方法都添加了**synchronized关键字**，也就是给这个方法添加了一个锁，用来保证线程安全。，而StringBuilder则没有实现线程安全功能，所以性能略高。
## new String在内部存储结构发生什么？
使用这种方式创建两个对象（StringPool中没有）。
1. “abc”是字符串字面量，编译时会在StringPool中创建一个对象，指向字面量。
2. 使用new的方式会在堆中创建一个字符串对象。
## abstract 和 interface
1. abstract：含有abstract修饰符的类即为抽象类。抽象类不能有实例对象。含有abstract的抽象方法的类必须声明为抽象类。抽象类中的方法不一定都是抽象方法。abstract类中的抽象方法必须在子类中实现，所以不能有抽象静态方法和抽象构造方法。如果子类中没有实现所有的abstract方法，子类也必须被声明为abstract类。接口可以说成是抽象类的一个特例，接口中的所有方法必须为抽象方法。接口中的成员方法定义为public abstract类型，所有的成员变量默认定义为public static final。
2. abstract和interface的区别：①接口中不能有构造方法，抽象类中可以有构造方法。②抽象类中可以有普通成员变量，接口中不可以有普通成员变量。③抽象类中可以包含非抽象的普通方法，接口中只能包含抽象方法，不能包含非抽象的普通方法。④抽象类中的抽象方法可以使public和protected，接口中的抽象方法只能是public的，默认是public abstract。⑤抽象类中可以有静态方法，接口中不能有静态方法。⑥抽象类中可以包含任意类型的静态成员变量，接口中只能包含public static final的静态成员变量，并且默认为public static final。⑦一个类可以实现多个接口，但只能继承一个类。
3. 接口更多的是在系统架构设计方面发挥作用，定义模块之间的通信契约。抽象类更多的是在代码实现方面发挥作用，可以实现代码复用。
4. 模板方法设计模式是抽象类的一个典型应用。
## 你知道的内部类有哪些java当中的？
1. AQS中的node和conditionobject
2. 建造者模式中的内部类
3. ReentranLock的内部类，线程安全集合中的内部类node。
4. HashMap
5. ThreadLocal
## 静态内部类和内部类有什么区别？
### 普通内部类
1. 普通内部类中不能有静态成员变量和静态成员方法
2. 想要引用内部类，必须创建外部类的引用，即内部类不能离开外部类而独立存在
3. 可以内部类理解为外部类的一个成员，一个内部类对象可以访问创建它的外部类对象的内容，需要注意的是内部类里的一个成员变量与外部类的一个成员变量同名，也即外部类的同名成员变量被屏蔽，那么如果需要访问外部类的成员变量可以通过：外部类名.this.变量名
4. 所有的内部类都需要注意其构造方法，所有的内部类都没有无参的构造器，系统都会为其增加一个默认的构造参数。因为所有的内部类都有一个默认的构造参数，其值为外部类对象，这样也就更好的理解了对于外部类。
### 静态内部类
1. 普通静态和非静态类的区别就在于静态内部类没有了指向外部的引用。
2. 普通静态内部类如果想要使用外部类中的成员（包括属性和方法），那么要求对应的成员是static的。
3. 静态内部类是属于相应的外部类的静态成员。
### 初始化的时候静态内部类什么时候初始化？
静态内部类的加载不需要依附外部类，在使用时才加载。不过在加载静态内部类的过程中也会加载外部类。
### 为什么静态方法调用非静态方法是错误的？
1. 静态方法属于类，当调用非静态方法时，不知道调用哪个对象的非静态方法。
2. 在加载过程来看，静态方法在类加载的时候被保存在方法区中，非静态方法随着对象的创建被保存在堆中。非静态方法可以直接通过类名进行访问，此时不需要类的实例化，也就是说非静态方法是不存在的，对于访问一个不存在的方法，就会报错。
## 面向对象和面向过程的区别
面向过程：面向过程性能比较高。因为类调用时需要实例化，开销比较大，比较消耗资源，所有当性能是最重要的考量因素的时候。面向过程没有面向对象易维护、易复用、易扩展等。
面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态的特性，所有可以设计出低耦合的系统，是系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。

面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型项目，软件复用和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。

例如开门这个动作，面向过程是 open(Door door)，动宾结构，door 作为操作对象的参数传入方法，方法内定义开门的具体步骤。面向对象的方式首先会定义一个类 Door，抽象出门的属性（如尺寸、颜色）和行为（如 open 和 close），主谓结构。

面向过程代码松散，强调流程化解决问题。面向对象代码强调高内聚、低耦合，先抽象模型定义共性行为，再解决实际问题。
## 面向对象的三大特征？
封装
继承
多态：编译时多态，主要指方法的重载。运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定。运行时多态的三个条件：继承，覆盖(重写)，向上转型
## 异常
异常分为error和exception。都继承Throwable。exception能被程序本身处理，而error不能被程序本身处理，只能尽量避免。
exception分为checkexception和uncheckexception。IOexception为checkexception，在编写代码的时候必须被捕获。而RuntimeException为uncheckexception，在编写代码的时候可以不被捕获。
不受检查的异常：NullPointException、ClassCastException、NumberFormatException、ArrayOutOfBoundException、ArithmeticException。
受检查的异常：FileNotFoundException、SQLException。
## try catch finally
在以下三种特殊情况下finally不会被执行：System.exit()在finally之前。CPU关闭，线程死亡。
## Object有什么方法，什么时候用到hashcode方法?
1. clone，getClass，toString，finalize，equals，hashcode，wait，notify，notifyAll
2. 在重写equals的时候，必须重写hashcode。首先用hashcode判断两个类是否相等，接着在用equals判断。
## 反射
1. 可以获取一个类的所有属性和方法，还可以调用这些属性和方法。
2. 缺点：让我们在运行时有了分析操作类的能力，同样增加了安全问题比如无视泛型参数的安全检查。
## cglib反射和jdk反射的区别
- JDK是基于反射机制,生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强。它生成类的速度很快,但是运行时因为是基于反射,调用后续的类操作会很慢。而且他是只能针对接口编程的.
- CGLIB是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用。它底层是基于asm第三方框架,是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理。生成类的速度慢,但是后续执行类的操作时候很快。可以针对类和接口。
- 因为jdk是基于反射,CGLIB是基于字节码.所以性能上会有差异。
## 泛型
泛型提供了编译时类型检查机制，该机制允许程序员在编译时检测到非法类型。泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。
## SPI机制
## 什么是序列化，什么是反序列化
如果我们需要持久化java对象必须把java对象保存到文件中或者在网络中传输java对象，都需要用到序列化。
1. 序列化：把数据结构或对象转换成二进制字节流的过程。
2. 反序列化：把二进制字节流转换成数据结构或对象的过程。
如果不想序列化可以使用transient关键字。transient只能修饰变量，不能修饰类和方法。在反序列化的过程中，被transient修饰的变量值会被置为类型的默认值。static变量属于类，不属于某个对象，所以不论是否被transient修饰，都不会被序列化。
## java中IO流分为几种？

## 既然有了字节流为什么还要字符流？
字符流是java虚拟机将字节转换得到的，这个过程是十分耗时的，如果我们不知道编码类型很容易出现乱码问题。所以IO流就直接提供了一个操作字符的接口，方便我们平时对字符进行流处理。对于音频，图片等媒体文字采用字节流比较合适，如果涉及到字符的话使用字符流比较好。
## socket套接字
套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机的进程进行双向通信的端点。是通信双方的一种约定，用套接字的相关函数来完成通信过程。处于应用层和传输层之间。
## 常用注解说一下
- spring中的各种注解
- Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。 
- 元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，source，源代码，class，编译期保留，runtime：运行期保留，可利用反射获取注解信息。@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。
- 注解不支持继承，不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation。Annotation接口. 虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。 区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。
- 注解是一个接口，是一个继承自Annotation的接口。里面的每一个属性其实就是接口的一个抽象方法。注解@interface 是一个实现了Annotation接口的 接口， 然后在调用getDeclaredAnnotations()方法的时候，返回一个代理$Proxy对象，这个是使用jdk动态代理创建，使用Proxy的newProxyInstance方法，传入接口 和InvocationHandler的一个实例(也就是 AnotationInvocationHandler ) ，最后返回一个实例。期间，在创建代理对象之前，解析注解时候 从该注解类的常量池中取出注解的信息，包括之前写到注解中的参数，然后将这些信息在创建 AnnotationInvocationHandler时候 ，传入进去作为构造函数的参数。
## 面向对象编程的五大原则
1. 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
2. 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
3. 里氏替换原则：子类应该完全替换父类。应该在使用继承的时候，只扩展新功能，不破坏父类原有的功能。
4. 依赖倒置原则：细节应该依赖于抽象，抽象不应该依赖于细节。把抽象层放到程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
5. 迪米特法则：最少知道原则，一个类不应该直到自己操作类的细节。
6. 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，应该将接口拆分，让实现类只需依赖自己需要的接口方法。
## 设计模式
### 构建型模式
#### 工厂方法模式
##### 简单工厂模式
将实例化的工作交给工厂来做，我们只需要告诉工厂我们需要什么东西就好了。
缺点：如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。修改此工厂的原因不止一个，违背了**单一工厂原则**。当要生产新的产品时，必须在工厂类中添加新的分支，违背了**开闭原则**。
##### 工厂方法模式
为了解决简单工厂模式的两个弊端，规定每个产品都有一个专属工厂。
##### 抽象工厂模式
在创建时指定了具体的工厂类后，在使用时就无需关心是哪个工厂类，只需要将此工厂当做抽象的IFactory接口使用即可。
缺点：抽象工厂模式太重了，如果IFactory接口需要新增功能，则会影响到所有的具体工厂类。
抽象工厂模式适合新增同类工厂这样的横向扩展，不适合新增功能这样的纵向扩展。
#### 单例模式
某个对象全局只需要一个实例时，就可以使用单例模式，能够避免对象的重复创建，节约空间提升效率。避免由于操作不同实例导致的逻辑错误。分为饿汉式和懒汉式。**构造方法为private**，这样就保证了其他类无法实例化此类，必须通过getInstance方法才能获取到唯一的instance实例。
```java
public class Singleton {
    //私有化构造方法
    private Singleton() {
    }

    //在类中创建一个对象
    public volatile static Singleton instance;

    //添加公开的方法，返回这个对象
    public static Singleton getInstance() {
        if (instance == null) {//DCL--Double Check Lock 双重检查锁,提高效率
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                    //1 在堆中开辟空间，属性默认值
                    //2 调用构造方法，给属性赋值
                    //3 把地址放入局部变量
                }
            }
        }
        return instance;
    }
}
```
#### 建造型模式
用于创建过程稳定，但配置多变的对象。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。静态内部类Builder，链式调用生成不同的配置。构造方法也是私有的，只能通过静态内部类来创建实例。
#### 原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
### 结构型模式
#### 适配器模式
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作。
#### 桥接模式
面向两个或多个同等级的接口。将抽象部分与实现部分分离，二者相互独立，实现抽象化与实现化解耦。`比如对形状和颜色进行分离，然后根据需要对颜色和形状进行组合。`
#### 组合模式
组合模式用于整体和部分的结构。当整体和部分有相似的结构，在操作时可以被一直对待时，就可以使用组合模式。
#### 装饰器模式
用于增强一个类原有的功能，为添加一个类新的功能。
#### 代理模式
给某一个对象提供一个代理，并由代理对象控制原对象的引用。
### 行为型模式
#### 责任链模式
责任链主要用于助力职责相同，程度不同的类。`比如在对不同难度的任务进行处理的时候，可以将初级工程师、中级工程师、高级工程师这三种角色用链串联起来，然后将任务在初级工程师开始，谁有能力处理就在谁那处理。`
#### 观察者模式
一个对象发生一个事件后，逐一通知监听这个对象的监听者。监听者可以马上对这个事件做出反应。
#### 模板方法模式
定义了一个操作中的算法的骨架，而将一些操作延迟到子类，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些步骤。
如果不希望子类覆写模板中的某些方法，使用final修饰该方法，如果希望子类中必须覆写模板中的某些方法，使用abstract修饰该方法。如果没有特殊要求，可使用protected或public修饰该方法。子类可以根据实际情况考虑是否覆写。
## bitset、bitmap
### bitmap算法
- bitmap的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，可以很大力度的节省空间，常用于对大量整数做去重和查询操作。
- 32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。
- 在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存。如果将20亿个整数放入内存中，需要占用多少内存？如果每个数字都以int类型存储，20亿整数占用内存=20亿*4byte/1024/1024/1024 约等于 7.45G。如果使用bit-map的思想，按位存储，即一位就可以代表一个数字。20亿整数占用内存=20亿*1bit/8/1024/1024/1024=约等于0.233G。从上述结果来看，按位存储比按字节存储数字节约了（7.45/0.233-1约等于31倍空间），而且按字节存储根据内存4G的要求无法一次性在内存中进行处理。
- 快速去重：20亿个整数中找出不重复的整数的个数，内存不足以容纳这20亿个整数。 首先，根据“内存空间不足以容纳这20亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这20亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间2G左右。接下来的任务就是把这20亿个数字放进去（存储），如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次。最后，统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。
### bitset
BitSet实现了一个位向量，它可以根据需要增长。每一位都有一个布尔值。一个BitSet的位可以被非负整数索引。可以查找、设置、清除某一位。通过逻辑运算符可以修改另一个BitSet的内容。默认情况下，所有的位都有一个默认值false。
### 布隆过滤器
1. 首先需要 k 个 hash 函数，每个函数可以把 key 散列成为 1 个整数；
2. 初始化时，需要一个长度为 n 比特的数组，每个比特位初始化为 0；
3. 某个 key 加入集合时，用 k 个 hash 函数计算出 k 个散列值，并把数组中对应的比特位置为 1；
4. 判断某个 key 是否在集合时，用 k 个 hash 函数计算出 k 个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在
### 怎么解决hash冲突
开放地址法，拉链法。hashmap中使用拉链法，threadlocal中使用开放地址法。
## tomcat出问题了，怎么通过日志排查
## tomcat线程安全问题
## 红黑树
1. 每个节点要么是红色，要么是黑色。
2. 根节点必须是黑色
3. 红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。
4. 对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点
# 操作系统

<!--ts-->
- [操作系统](#操作系统)
  - [概述](#概述)
    - [什么是操作系统](#什么是操作系统)
    - [操作系统的基本功能](#操作系统的基本功能)
    - [操作系统的特点](#操作系统的特点)
    - [用户态切换到内核态的三种方式](#用户态切换到内核态的三种方式)
    - [什么是系统调用](#什么是系统调用)
    - [linux进程内存空间分为哪几个段](#linux进程内存空间分为哪几个段)
  - [进程](#进程)
    - [进程和线程的区别](#进程和线程的区别)
    - [同一进程中不同线程共享哪些资源？](#同一进程中不同线程共享哪些资源)
    - [进程有哪几种状态](#进程有哪几种状态)
    - [线程的6种状态](#线程的6种状态)
    - [进程间通信的方式](#进程间通信的方式)
    - [线程间同步的方式](#线程间同步的方式)
    - [进程的调度算法](#进程的调度算法)
    - [进程调度算法的优缺点](#进程调度算法的优缺点)
    - [孤儿进程](#孤儿进程)
    - [僵尸进程](#僵尸进程)
    - [经典同步问题](#经典同步问题)
  - [死锁](#死锁)
    - [死锁的必要条件](#死锁的必要条件)
    - [死锁和CPU利用率之间的关系](#死锁和cpu利用率之间的关系)
    - [死锁的处理方法](#死锁的处理方法)
    - [死锁的检测与恢复](#死锁的检测与恢复)
      - [1. 死锁的检测](#1-死锁的检测)
      - [2. 死锁的恢复](#2-死锁的恢复)
    - [死锁的预防](#死锁的预防)
    - [死锁的避免](#死锁的避免)
  - [内存管理](#内存管理)
    - [操作系统的内存分配算法有哪些?](#操作系统的内存分配算法有哪些)
    - [什么是内存管理](#什么是内存管理)
    - [常见的几种内存管理机制](#常见的几种内存管理机制)
    - [内存分段](#内存分段)
    - [内存分页](#内存分页)
    - [MMU(内存管理单元)](#mmu内存管理单元)
    - [段页式内存管理](#段页式内存管理)
    - [分页和分段分别是解决什么问题](#分页和分段分别是解决什么问题)
    - [快表和多级页表](#快表和多级页表)
    - [快表为什么比页表快？](#快表为什么比页表快)
    - [分页和分段的比较](#分页和分段的比较)
      - [逻辑(虚拟)地址和物理地址](#逻辑虚拟地址和物理地址)
      - [为什么需要虚拟地址空间](#为什么需要虚拟地址空间)
    - [虚拟内存](#虚拟内存)
      - [什么是虚拟内存(内存管理的技术，定义了一个连续的虚拟地址空间，并把内存扩展到硬盘空间)](#什么是虚拟内存内存管理的技术定义了一个连续的虚拟地址空间并把内存扩展到硬盘空间)
      - [局部性原理](#局部性原理)
      - [虚拟存储器](#虚拟存储器)
      - [虚拟内存的技术实现](#虚拟内存的技术实现)
      - [页面置换算法](#页面置换算法)
  - [文件管理](#文件管理)
    - [三种控制IO设备的方法](#三种控制io设备的方法)
    - [DMA技术(直接内存访问)](#dma技术直接内存访问)

<!-- Added by: hanzhigang, at: 2021年 8月17日 星期二 13时48分03秒 CST -->

<!--te-->

## 概述
### 什么是操作系统
1. 操作系统是管理计算机硬件和软件程序的程序，是计算机的基石。
2. 操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。
3. 操作系统的存在屏蔽了硬件层的复杂性。
4. 操作系统的内核是操作系统的核心部分，它负责系统的内存管理，设备管理，文件系统管理和应用程序的管理。

### 操作系统的基本功能
1. 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等
2. 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等
3. 设备管理：文件存储空间的管理、目录管理、文件读写管理和保护等
4. 文件管理：完成用户I/O请求，方便用户使用各种设备，并提高设备的利用率。主要包括：缓冲管理、设备分配、设备处理、虚拟设备等。

### 操作系统的特点
- 共享：操作系统中的资源可以被多个并发进程使用。互斥共享和同时共享。
- 虚拟：虚拟技术把一个物理实体转换成多个逻辑实体。
- 并发：在一段时间内同时运行多个程序。
- 异步：进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

### 用户态切换到内核态的三种方式
- 中断：当外围设备完成用户请求后，会向CPU发出相应的中断信号，这时CPU会暂停执行当前进程的指令，转而执行与中断信号对应的处理程序。
- 异常：当CPU执行运行在用户态下的程序时，发生了某些实现不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核的相关的程序中，比如缺页异常。
- 系统调用：进程通信，进程控制，文件操作，设备操作。

### 什么是系统调用
- 用户态和内核态：用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。
- 用户态可以直接读取应用程序中的数据。内核态：操作系统运行的进程或程序几乎可以访问系统的任何资源。
- 当用户态的应用程序想要调用内核态的子功能时需要用到系统调用。也就是说应用程序凡是需要用到与内核态级别的资源有关的操作，都需要通过系统调用向操作系统发出服务请求，由操作系统代为完成。
- 系统调用：进程控制、进程通信、文件操作、设备操作等。
1. 用户态把一些数据放到寄存器，或者创建对应的堆栈，表明需要操作系统提供的服务。
2. 用户态执行系统调用（系统调用是操作系统的最小功能单位）。
3. CPU切换到内核态，跳到对应的内存指定的位置执行指令。
4. 系统调用处理器去读取我们先前放到内存的数据参数，执行程序的请求。
5. 调用完成，操作系统重置CPU为用户态返回结果，并执行下个指令。

### linux进程内存空间分为哪几个段
1. Text，代码区：存放可执行的指令操作，只读不可写。
2. Bss，静态区/全局区：存在未初始化的全局变量和静态变量。
3. Data，数据区：存在初始化的全局变量和静态变量。
4. Stack：存放临时变量和函数参数。
5. Heap：存放new/malloc等动态申请的变量，用户必须手动进行delete/free操作。 其中Stack和Heap的内存增长方向是相反的。

## 进程
### 进程和线程的区别
- 进程是资源分配的基本单位。线程不拥有资源，但是线程可以访问隶属进程的资源
- 线程是独立调度的基本单位。在同一个进程内的线程之间切换不会引起进程切换，但是从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。
- 线程的开销比进程的开销要小。进程的创建或撤销需要分配或者回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销时的开销。
- 线程间可以通过直接读写同一进程内的数据进行通信。

### 同一进程中不同线程共享哪些资源？
- 堆
- 静态变量
- 全局变量
- 文件等公共资源
线程共享的环境包括：进程的代码段(方法区)、进程打开的文件描述符、进程的公共数据(方法区的运行时常量池)、信号的处理器、进程当前目录和进程用户

### 进程有哪几种状态
- 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态
- 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行
- 运行状态：进程处于就绪状态被调度后，进程进入执行状态
- 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用
- 结束状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

### 线程的6种状态
- 创建状态
- 运行状态
- 阻塞状态
- 等待状态
- 超时等待状态
- 结束状态

### 进程间通信的方式
- 匿名管道/管道：创建一个匿名管道，返回两个文件描述符，一个读取端文件描述符fd[0]，一个写入端文件描述符fd[1]。匿名管道是特殊的文件，只存在于内存，不存在于文件系统。所谓管道是内核中的一段缓存，从管道的一端写入的数据，是存在内核中的，另一端读取也就是在内核中读取数据。管道的传输的数据是无格式的且大小受限的。fork一个子进程，子进程会复制父进程的文件描述符，`ps -ef | grep java`
- 有名管道
**管道的数据传输是单向的，**
- 共享内存：拿出一块虚拟地址空间表，映射到相同的物理内存上。
- 消息队列：管道的传输效率是很低的，不适合频繁的进程间的交换数据。消息队列是存在在内核中的消息链表，在传输数据的时候会分成一个个的消息体，传输的消息体是用户自定义的数据类型，在传输开始前两个进程约定好数据类型，不像管道只能传输无格式的字节数据。消息队列会随着内核，如果没有释放消息队列或者没有关闭操作系统，消息队列是一直存在的。不像管道是随着进程的创建而创建，销毁而销毁。消息队列是双向的。消息队列不适合比较大数据的传输，每个消息体有一个最大长度的限制，同时所有队列包含的全部消息体的总长度也有上限。消息队列数据传输过程中，存在用户态和内核态之间的数据拷贝。当进程写入到进程的消息队列中时，会将用户态的数据拷贝到内核态中。当进程读取内核态中的消息队列时，会发生内核态拷贝数据到用户态的过程。
- 信号：信号是进程间通信唯一的异步通信机制。任何时候发给信号给某一个进程，一旦有信号产生，就会执行相应的信号处理方式。
- 信号量：当多个进程访问一块共享资源时，会发生数据错乱，所以需要保护机制。信号量实际是一个整形的计数器，主要用于实现进程间的互斥和同步，不用于缓存进程间通信的数据。
- 套接字：两个主机之间的进程进行通信。

### 线程间同步的方式
- 互斥量：只允许一个线程访问当前资源。
- 信号量：允许多个线程访问同一资源，但是有数量限制。
- 事件：wait/notify
- 临界区

### 进程的调度算法
- 先到先服务调度算法
- 优先级调度算法
- 时间片轮转调度算法:系统把所有就绪进程按先入先出的原则排成一个队列。先来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序就是选出就绪队列的队首进程，然后将它PCB中的现场信息(包括程序状态字，程序计数器，各通用寄存器等)存入相应的寄存器中，让它在cpu上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给他的时间片后，系统的计时器发出时钟中断，调度程度便停止该进程的执行，把它放入就绪队列的末尾，然后接着把cpu分给就绪队列的队首进程。
- 短作业优先调度算法
- 多级反馈队列调度算法

### 进程调度算法的优缺点
1. 时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。
2. 先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。
3. 优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。
4. 多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。
5. 高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大。
### 孤儿进程
一个父进程退出，一个或多个子进程还在运行，这些进程被称为孤儿进程。
孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。由于孤儿进程会被init进程所收养，所以孤儿进程不会对系统造成危害。

### 僵尸进程
一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或者waitpid()获取了子进程的信息后才会释放。如果子进程退出，父进程并没有调用wait()或者waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程。
系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
要消灭系统中大量的僵尸进程，只需要将父进程杀死，这些子进程就会变成孤儿进程，被init进程收养，这样init进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

### 经典同步问题
1. 哲学家进餐问题
2. 读者-写者问题
3. 生产者消费者问题

## 死锁
### 死锁的必要条件
1. 互斥：每个资源要么分配给一个进程，要么就是可用的
2. 占有且等待：已经得到了某个资源的进程可以再请求新的资源
3. 不可抢占：已经分配给一个进程的资源不能强制性的被抢占，它只能被占有它的进程显示的释放
4. 循环等待：有两个或者两个以上的进程组成一条环路，该环路中每个进程都在等到下一个进程占有的资源。
### 死锁和CPU利用率之间的关系
死锁和CPU利用率之间的关系与锁的实现有关系
1. 锁的实现形式不是CAS的时候，此时没有获取到锁，不会分配到cpu，此时cpu利用率是0.
2. 当锁的实现形式是CAS的时候，此时一直处于忙等待，这时候CPU利用率会飙升。
### 死锁的处理方法
1. 鸵鸟策略
2. 死锁的检测和恢复
3. 死锁的预防
4. 死锁的避免
### 死锁的检测与恢复
#### 1. 死锁的检测
#### 2. 死锁的恢复
- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复
### 死锁的预防
1. 破坏互斥条件
2. 破坏占有且等待条件：规定所有进程在开始执行前请求所需要的全部资源。
3. 破坏不可抢占条件
4. 破坏环路等待条件：给资源统一编号，进程只能按编号顺序来请求资源。
### 死锁的避免
1. 安全状态
2. 单个资源的银行家算法
3. 多个资源的银行家算法

## 内存管理
### 操作系统的内存分配算法有哪些?
1. 位图算法：概念： 这种位图即二维数组，通过二维数组来保存内存的使用情况，每个位的值代表这个块的使用情况，0为空闲，1为被占用。优点： 查找快；对于内存的管理比较清晰可见。缺点： 需要通过遍历的方式才能知道哪些内存是可以使用的，并且这种内存分配方式不能避免内存碎片的问题。
2. 链式算法：这种分配算法通过链表来保存和维护块的使用信息，它包括多个单元，每个单元是一个连续的数组，数组的第一位用来表示这个数组是用来表示的是已占用块信息还是空闲块信息，第二位是块的起始点，第三位表示从这个位置出发有多少个块是被占用（空闲）的，数组的最后一位存放的是指向下一个数组的首部地址的指针。当某个块可以直接被使用时，就可以修改它的状态并分配内存；如果只需要使用其中的一部分，那么可以把它拆开，分为两个链表元素，当被分配的块被释放后，再合并这两块内存。
3. 伙伴(buddy)算法：这种方式基于数组结合链表来实现，它解决了链式算法查找慢的问题，伙伴算法对不同大小的内存进行分类管理，可以根据内存分配的需求直接定位到相应位置，提升内存查找速度。伙伴算法的数据结构是通过一个free_area的数组，找到合适的数量级的位置，这个位置维护着一段链表，如果对应链表元素可用，就进行分配，同时还可以对剩下的内存进行拆分，并把它们调整到低数量级，可用于分配小对象，当这块内存对应区域被释放后，就可以和相邻的内存区间合并，再添加到高一数量级的数组位置。
4. slab算法：slab在一定程度上优化了伙伴算法的小对象浪费内存的问题，slab分配器在操作系统初始化的时候就维护了一个缓存区域，维护了一个slabs列表，每个slab中存储着若干对象，用来缓存内核中需要频繁创建和销毁的小对象，对它们完成初始化操作，并放置在缓存中，以实现通用对象的复用。
### 什么是内存管理
- 逻辑地址到物理地址的映射
- 内存的分配与回收
### 常见的几种内存管理机制
- 连续的：块式内存管理
- 离散的：页式内存管理、段式内存管理、段页式内存管理
1. 段页式内存管理：既有了分段系统的共享和保护，又有了分页系统的虚拟内存功能。

### 内存分段
1. 段号：段基地址，段偏移量
2. 堆段、栈段、数据段、代码段
3. 分段的好处是能产生连续的内存空间
4. 分段的不足：内存碎片(内碎片和外碎片)、内存交换效率低(访问硬盘的速度比内存的速度低，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。)

### 内存分页
1. 页号(虚拟页号、物理页号)和页偏移量
2. 通过页表来进行地址转换，页表存在MMU中。页表包括物理页号每页所在的物理内存的基地址。

### MMU(内存管理单元)
1. 页表：虚拟地址和物理地址的映射
2. 地址转换和TLB（快表）的访问与交互

### 段页式内存管理
1. 段号，段内页号，页内偏移

### 分页和分段分别是解决什么问题
- 分页是为了实现虚拟内存，从而获得更大的地址空间
- 分段是为了使程序和数据在逻辑上可以被划分为独立的地址空间，并且有利于共享和保护。

### 快表和多级页表
- 分页内存管理中：`虚拟地址到物理地址的转换要快`。`解决虚拟地址空间大，页表也会很大的问题`。
- 快表：局部性原理的概念，将最近访问到的页面或段放到内存中的快表中，当访问的页或者段不在内存中时，首先先去快表中查找，如果快表中存在则直接使用，如果不存在在快表中，则调用相应的页面调度算法，将需要的页或段放入快表中。
- 多级页表：**对局部性原理的充分利用**。为了避免全部页表一直存放到内存中，占用过多的空间，将那些不需要的页表存放到磁盘中。
- 二级页表：每个页表占4k内存，一个页表项占4字节。例如一个进程的虚拟内存空间占4G，进程真正使用的内存空间占4M，那么使用一级页表需要用4M内存来存放虚拟内存空间对应的页表，然后再找到占用的4M的内存空间。如果使用二级页表的话，使用4K的内存来定位页表项，然后真正的内存空间4M对应的页表项的大小为(4M = 1024 * 4K)4K，则最终只需要4K + 4K = 8K的内存空间。
- 使用一级页表需要访问2次内存，使用二级页表需要访问3次内存。

### 快表为什么比页表快？
1. 快表是一种特殊的高速缓冲存储器(Cache)，内容是页表的一部分或者全部内容。引入快表是为了加快地址映射速度，在虚拟页存储管理中设置了快表，作为当前页表的Cache。通常快表存放在MMU中。
- 快表和页表的区别和联系
1. 页表指出逻辑地址中的页号和所占主存物理块号的对应关系。页式存储管理在用动态重定位方式装入作业时，要用页表做地址转换工作。
2. 快表是存放在高速缓冲存储器中的部分页表。作为页表的Cache，它的作用与页表相似，但提高了访问内存效率。在页式存储管理中，利用页表做地址转换，读写数据需要访问内存两次（去内存读页表，利用得到的绝对地址去读内存），但是快表是存放在MMU中的，利用快表做地址转换，只需要读一次高速缓冲存储器，读一次内存，这样可以加速数据的查找和提高指令的执行速度。

### 分页和分段的比较
- 分页和分段都是为了提高内存利用率，减少内存碎片。
- 段和页都是离散存储的，段和页中的内存都是连续的。
- 分页对程序员来说是透明的，分段需要程序员显式的划分每个段。
- 页的大小是不可变得，段的大小是可变的。
- 地址空间的维度：页的地址空间是一维的，段的地址空间是二维的。
- **出现的原因：** 分页是主要是用于实现虚拟内存，从而可以获得更大的地址空间。分段是为了使程序和数据在逻辑上可以被划分为独立的地址空间，并且有利于共享和保护。段是逻辑信息的单位，在程序中可以体现为代码段和数据段，能够更好满足用户的需要。

#### 逻辑(虚拟)地址和物理地址

#### 为什么需要虚拟地址空间
1. 如果没有虚拟地址，程序都是直接访问物理地址，程序可以访问任意内存，很容易破坏操作系统，造成操作系统崩溃。然后无法运行多个应用程序，多个应用程序读取同一个物理内存地址，数据容易被覆盖，造成应用程序的崩溃。
2. 通过虚拟地址访问可以有以下优势：(1)程序可以使用虚拟地址访问内存中不相邻的大内存缓冲区。(2)使用虚拟地址访问大于可用物理内存的内存缓冲区，当物理内存可用量变小时，可以根据需要将代码或数据在磁盘和内存中移动。(3)不同进程使用的虚拟地址彼此隔离，一个进程无法更改由另一进程正在使用的物理内存。
### 虚拟内存
#### 什么是虚拟内存(内存管理的技术，定义了一个连续的虚拟地址空间，并把内存扩展到硬盘空间)
- 让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
- 为了更好的管理内存，将内存抽象成地址空间，每个程序都拥有自己的地址空间。每个地址空间分割成多个块，每个块成为一页，每一页映射到相应的物理内存上，但不需要映射到连续的物理内存上，也不需要所有的页必须在物理内存中。当程序引用到不在物理内存中的页时，将缺失的部分装入物理内存。
- 使应用程序错觉的认为自己拥有一段连续物理内存的错觉，实际上虚拟内存为应用程序分配了一段封闭的，连续的地址空间，地址空间分割成多个块，每个块为一页，分别映射到了不同的物理碎片上，有的还部分暂时的保存到了物理磁盘上。当应用程序需要的页不在内存空间中时，将缺失的部分装入物理内存中。
#### 局部性原理
- 空间局部性：一旦应用程序访问到某个存储单元，在不久之后，附近的存储单元也可能被访问到。因为程序所访问的地址，可能集中在一定范围内，指令通常是顺序存放，顺序执行，数据一般以向量、数组等形式簇聚存储。
- 时间局部性：程序中某个指令一旦执行，不久之后，该指令可能被再次执行。该数据被访问过，一段时间之后可能会被再次访问。(程序中存在大量的循环)
#### 虚拟存储器
- 时间换空间的概念
- 一部分程序被装入内存，当访问的数据或代码不在内存中时，将物理磁盘中的部分数据调入内存。
#### 虚拟内存的技术实现
- 在离散分配的内存管理方式的基础上
- 请求分页存储管理：建立在分页管理之上，为了支持虚拟存储功能而增加的请求调页功能和页面置换功能。在程序运行之前，将部分页调入内存，使程序能够正常运行。当遇到程序请求的页不在内存中时，系统调用页面置换算法，将部分页调入内存，同时，也将部分用不到的页调出内存。
- 请求分段存储管理：建立在分段管理之上，提供了请求调段功能和分段置换功能。程序运行之前调入部分段使程序能够运行起来。可以使用请求调入中断，将程序即将使用到的段而又不在内存中的调入内存。当内存空间快满时，又可以将部分段调出内存。
- 请求段页式存储管理
#### 页面置换算法
- OPT最佳页面置换算法
- FIFO先进先出页面置换算法
- LRU最近最久未使用页面置换算法
- LFU最少使用页面置换算法

## 文件管理

### 三种控制IO设备的方法
1. 使用程序控制IO
2. 使用中断驱动IO
3. 使用DMA的IO

### DMA技术(直接内存访问)
在没有DMA技术之前，IO的过程是这样的：
- CPU发出对应的指令给磁盘控制器，然后返回。
- 磁盘控制器收到指令后就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断。
- CPU收到中断信号，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节的读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间CPU是无法执行其他任务的。

DMA技术：在进行IO设备(磁盘控制器)和内存(内核缓冲区)的数据传输的时候，数据搬运的工作全部交给DMA控制器，而CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务。大致过程：
- 用户进程调用read方法，向操作系统发出IO请求请求读取数据到自己的内存缓冲区，进程进入阻塞状态。
- 操作系统收到请求后，进一步将IO请求发送DMA，然后让CPU执行其他任务。
- DMA进一步将IO请求发送给磁盘。
- 磁盘收到DMA的IO请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向DMA发出中断信号，告知自己的缓冲区已满。
- DMA收到磁盘信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用CPU，CPU可以执行其他任务。
- 当DMA读取足够多的数据，就会发出中断信号给CPU。
- CPU收到DMA的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回。

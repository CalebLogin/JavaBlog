# JVM
## 类加载过程
加载-验证-准备-解析-初始化
### 类的加载
1. 通过一个类的全限定名来获取其定义的二进制流
2. **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构**
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口
- 该阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需的格式存储在存储在方法区之中，而且在java堆中也创建了一个`java.lang.Class`类的对象，这样就可以通过该对象访问方法区中的这些数据。
- JVM允许类加载器预先加载类，但是碰到.class文件缺失或存在错误，要等到程序首次主动使用此类才报错，一直不被使用一直不报错。
- 加载类的方式：本地系统加载，网络下载.class文件，zip、jar中加载，从专有数据库中提取.class文件，将java源文件编译成.class文件。
### 验证
- 确保class文件的字节流中包含的信息符号符合当前虚拟机的要求，并不会危害虚拟机自身的安全。
1. 文件格式验证：验证字节流是否符合Class文件格式的规范，开头是否是0xCAFEBABE，主次版本号是否在虚拟机的处理范围之内，常量池中的数据类型是否有不被支持的。
2. 元数据验证：对字节码描述的信息进行语义分析，以保证描述的信息符合java语言描述的要求。
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。
4. 符号引用验证：确保解析动作能正确执行。
### 准备
- 为类的静态变量分配内存和初始化为默认值，**这些内存都将在方法区中分配**
1. 这时候进行内存分配的仅为类变量，不包括实例变量，**实例变量会在对象实例化时随着对象一起分配在Java堆中**
2. 初始值通常情况下是数据类型默认的零值，不是被在Java代码中被显式地赋的值。显式赋的值在初始化阶段才会执行。

- 对于局部变量，必须显示的赋值，否则编译时不通过。
- 对于同时被static和final定义的变量，声明的时候必须显式的赋值。只被final修饰的变量可以在声明时显式的赋值，也可以在类初始化的时候显式的赋值。
- 对于引用数据类型reference，如数组引用、对象引用等，如果没有显式的赋值而直接使用，系统默认为零值
- 数组初始化时没有对数组中的各元素赋值，默认零值

### 解析
- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
- 符号引用就是一组符号来描述目标，可以是任何字面量
- 直接引用直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
### 初始化
- 真正执行类中定义的Java程序代码(字节码)，初始化阶段是在执行初始化方法\<clinit>()方法的过程。
- 对于\<clinit>()方法的调用，虚拟机会确保自己在多线程环境中的安全性，是带锁线程安全，所以在多线程环境下进行类初始化可能会引起死锁。
- 主要对类变量进行初始化
- 初始化步骤:
1. 假设这个类还没有被加载和连接，则程序先加载并连接该类
2. 假设该类的父类还没有被初始化，先初始化其直接父类
3. 假设类中有初始化语句，系统依次执行这个初始化语句

- 类初始化时机：只有对类的主动使用的时候才会导致类的初始化
1. 当遇到new、getstatic、putstatic、invokestatic时。
2. 初始化某个类的子类，该类父类会被初始化。
3. 反射机制
4. 虚拟机启动时被表明为启动类的类

### 卸载
- 系统自带的类加载器(BootstrapClassLoader、ExtClassLoader、AppClassLoader)的实例不会被回收的，程序员自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

- 卸载需要满足的要求：
1. 该类中所有实例对象都被GC，堆中不存在该类的实例对象
2. 该类没有在任何地方被引用
3. 该类的类加载器的实例已被GC
### JVM类加载机制
#### 类加载机制
- 全盘负责：当一个类加载器负责加载某个类时，该类所依赖和引用的其他的class也要由该类加载器进行加载，除非显示使用另一个类加载器来载入。
- 父类委托：先让父类加载器尝试加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
- 缓存机制：保证所有被加载过的类都会被缓存，当程序需要使用某个类时，首先去缓存区中寻找该类，如果没有找到才去加载二进制数据，转换成class对象，存入缓存区。
- 双亲委派机制：如果一个类加载器收到类加载的请求，首先不会自己去尝试加载这个类，而是把请求委托加载给父加载器去完成。所有类加载请求都会到顶层的启动类加载器中，只有当父加载器无法加载该类时，子加载器才会去自己加载该类。

#### 双亲委派机制过程
1. 当AppClassLoader加载一个class时，它不会自己去尝试加载某个类，而是将类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它不会自己去尝试加载某个类，而是将类加载请求委派给父类加载器BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败，会使用ExtClassLoader去尝试加载。
4. 如果ExtClassLoader也加载失败，会使用AppClassLoader去尝试加载。如果加载失败，会报出ClassNotFoundException异常。

#### 双亲委派机制的好处
- 保证了app的稳定运行，避免了类被重复加载，也保证了java的核心api不被篡改。
#### 什么时候会打破双亲委派模型？
1. jdk中的基础类作为用户典型的api被调用，但是也存在被api调用用户的代码的情况。
2. SPI机制简介 SPI的全名为Service Provider Interface，SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。
3. 使用线程上下文类加载器，在jdbc的使用中，获取jdbc.drivers的属性，得到类的路径，然后通过系统类加载器加载，这时候系统类加载器加载了应用类加载器应该加载的类。
## JVM内存结构
### 程序计数器
- 较小的一块内存空间，**可以看作是当前线程所执行的字节码的行号指示器**。用来存储指向下一条指令的地址，即将执行的指令代码，由执行引擎读取下一条指令。
- 程序计数器的作用
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：顺序执行、选择、循环、异常处理。
2. 多线程环境中，程序计数器记录当前线程执行的位置，下次执行的时候能够继续执行。
- PC寄存器为什么线程私有？ 多线程在一个特定时间内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断和恢复。为了能够准确记录当前线程的执行位置，为每个线程分配一个PC寄存器，每个线程独立计算，不会相互影响。(上下文切换)
### 虚拟机栈
#### 栈帧
- 方法的调用都对应栈帧的出栈和入栈
- 内部结构：局部变量表，操作数栈，动态链接（指向运行时常量池的方法引用），方法返回地址（方法正常退出或异常退出的地址）
##### 局部变量表
- 主要用于存放方法参数和定义在方法体内部的局部变量，包括编译期可知的各种java虚拟机的基本数据类型，对象引用可能是指向对象起始地址的引用指针，也可能是指向一个代表一个对象的句柄。
- 如果该帧是由构造方法或者实例方法创建的，那么该对象引用this就会存在index为0的slot处。静态方法为什么不可以引用this，就是因为this不存在当前方法的局部变量表里。
##### 操作数栈
- 主要用于保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间。
- 栈顶缓存：基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。
##### 动态链接
- 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
- 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只有在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具有动态性，所以称为动态链接。
### 本地方法栈
### 堆
#### 内存划分
1. 分代的唯一理由就是优化GC性能。
2. 新生代，老年代，元空间。
3. TLAB：处于伊甸区，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量。一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。在内存读取方面堆是线程共享的，在内存分配方面，存在不共享的情况。
### 方法区
1. 用于存储类信息，常量池，静态变量，即时编译器编译后的代码缓存等。
2. 运行时常量池：一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息就是常量池表，包含这种字面量和对类型、域和方法的符号引用。
3. 常量池表是Class文件的一部分，用于存储编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。具有动态性，不要求常量一定在编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。
### 对象的内存布局
对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。

对象头占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。

类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。

实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。

对齐填充不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。
#### 对象的访问定位有哪两种方式？
- 使用句柄:Java 堆中将会划分出一块内存来作为句柄池，栈中的reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 直接指针
- 使用句柄来访问的最大好处是 栈中的reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
#### Java对象的创建过程
- 类加载检查：能够在常量池中定位到该类的符号引用，并检查这个类是否已经被加载过，解析和初始化过，如果没有必须执行相应的加载过程。
- 分配内存
  - 内存分配的两种方式：指针碰撞和空闲列表
  - 内存分配并发问题：CAS+TLAB
- 初始化零值
- 设置对象头
- 执行init方法

### JMM模型
1. as-if-serial:不管怎么重排序，单线程下的执行结果不能被改变
2. happen-before规则
①单一线程原则，在一个程序内，程序前面的操作先于发生程序后面的操作。
②管程锁定规则，一个unlock操作先行发生于后面对同一个锁的lock操作。
③volatile变量规则，对于一个volatile变量的写操作先行发生于后面对这个变量的读操作。
④线程启动规则，Thread对象的start发生先行发生于此线程的每一个动作。
⑤线程加入规则，Thread对象结束先行发生于join方法返回。
⑥线程中断规则，对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生。可以通过 interrupted() 方法检测到是否有中断发生。
⑦对象终结规则，一个对象的初始化先行发生于它的finalize方法的开始。
⑧传递性，如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。
- 所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。
- 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
- 线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。
- 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。
## Java垃圾回收
### 判断一个对象是否可被回收
1. 引用计数器法
2. 可达性分析算法：GC Roots一般包含：虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区类静态属性引用的对象，方法区中常量引用的对象。
3. 方法区的回收：该类的所有实例已经被回收，也就是堆中不存在该类的任何实例。该类的类加载器已经被回收。该类的类对象没有在任何地方被引用，也就是说无法通过反射访问该类方法。
### 引用类型
- 强引用，软引用，弱引用，虚引用。
- 强引用，任何时候都不会被jvm回收，即使oom。软引用：当内存不足时，会被回收。弱引用：每次gc的时候都会被回收，不管内存是否充足。虚引用：需要和referencequeue联合使用，当jvm扫描到虚引用的对象时，会先将此对象放到关联的队列中，因此我们可以通过判断队列中是否存在该对象，来了解被引用的对象是否将要被回收，进行一些回收前的处理。
- 使用场景：软引用：创建缓存，弱引用：WeakHashMap类中的key，可以使用WeakHashMap<String,Map<k,v>>保存事务的信息，在事务周期中，String对象的强引用一直存在，我们就一直可以获取信息，当事务结束时，弱引用可以自动帮我们清除map信息。虚引用：用于对象销毁前的一些操作，比如资源释放等。
### 垃圾回收算法
1. 标记-清除
2. 标记-整理
3. 复制
4. 分代收集
### 垃圾回收器
1. Serial垃圾回收器
Serial垃圾回收器，只会使用一个线程进行垃圾回收，新生代：复制算法，暂停所有用户线程，老年代：标记整理，暂停所有用户线程。
2. Serial Old垃圾回收器
3. CMS垃圾回收器
4. G1垃圾回收器
### CMS详解
- 初始标记：只是简单地标记一下gc root能关联的对象，时间很短，需要停顿，并发标记：进行GC Root Tracing的过程，耗时最长，不需要停顿，重新标记：修正并发标记期间因用户程序继续运行而产生变动的那一部分对象的标记记录，需要停顿。并发清除：不需要停顿。
- 缺点：吞吐量低，低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高。无法处理浮动垃圾，可能会导致Concurrent Mode Failure。浮动垃圾是指并发清除阶段用户程序继续运行而产生的，只能等到下次GC的时候才能会被回收。由于浮动垃圾的存在，老年代需要预存一段内存，CMS不能像其他垃圾回收器一样等到老年代快满时，再进行垃圾回收。如果预留的空间不足时，可能会导致Concurrent Mode Failure，将临时启用Serial Old来代替CMS。标记-清除算法导致碎片，往往出现老年代剩余，导致无法找到一块连续的足够大的内存空间存放对象，不得不提前触发一次full gc。
### G1详解
- G1垃圾回收器：其他垃圾回收器都是面向新生代或者老年代，G1可以直接对新生代和老年代一起回收。G1把堆分成多个大小相等的独立区域，新生代和老年代不再物理隔离。对每一个小块进行单独的垃圾回收，这种划分方法带来很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收可获得的空间，并维护一个优先列表，每次根据允许的收集时间，回收价值最大的Region。每个Region都有一个Remembered set，用来记录Region对象的引用所在的Region。通过使用Remembered set，避免在做可达性分析的时候进行全堆扫描。
- 初始标记，并发标记，最终标记，为了修正并发标记期间用户程序继续运行而产生变动的那部分记录，虚拟机将这段时间对象变化记录在线程的Remembered set logs中，最终标记阶段需要把Remebered set logs的数据合并到remembered set中，需要停顿用户线程，但是可以并行执行。筛选回收：首先对region中回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，此阶段也可以做到并发执行，但是因为只回收一部分region，时间是用户可控制的，而且停顿用户线程可以大幅度提高收集效率。
- 特点：空间整合，整体来看是基于标记-整理，局部来看(两个Region)，是基于复制算法，这意味着运行期间不会产生空间碎片。可停顿的预测：能让使用者指定在一个M毫秒的时间内，消耗在GC上的时间不超过N毫秒。
### 三色标记法
白色标记为未被标记的对象，灰色为自身被标记，成员变量未被标记，黑色为自身被标记，成员变量也被标记。
### 内存分配与回收策略
- 对象优先在伊甸区，大对象直接在老年代，空间分配担保，长期存活的对象进入老年代，动态对象年龄判定(当幸存区中的同年龄对象总和超过所有对象的一半时，大于等于年龄的对象直接进入老年代)。
- 空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。
### 什么时候触发full gc
System.gc，空间担保失败，Concurrent Mode Failure，老年代空间不足，1.7及之前的永久代空间不足。
## 调优参数
jps,jstack,jmap
## 内存泄漏和内存溢出
内存泄漏：在申请内存后无法释放已申请的内存空间就造成了内存泄漏。
内存溢出：程序在申请内存时，没有足够的内存供申请者使用。
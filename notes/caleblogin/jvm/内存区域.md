# 内存区域(运行时数据区)

### 概括
- 堆
- 元空间(1.6及之前叫方法区)
- 虚拟机栈
- 本地方法栈
- 程序计数器


### 程序计数器(PC寄存器)
- 较小的一块内存空间，**可以看作是当前线程所执行的字节码的行号指示器**。用来存储指向下一条指令的地址，即将执行的指令代码，由执行引擎读取下一条指令。
- 程序计数器的作用
    1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：顺序执行、选择、循环、异常处理。
    2. 多线程环境中，程序计数器记录当前线程执行的位置，下次执行的时候能够继续执行。
- PC寄存器为什么线程私有？
多线程在一个特定时间内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断和恢复。为了能够准确记录当前线程的执行位置，为每个线程分配一个PC寄存器，每个线程独立计算，不会相互影响。(上下文切换)



### Java虚拟机栈

#### 栈帧
对应着一次次的方法调用，是线程私有的，生命周期和线程一致。
- 栈帧:操作数栈，动态链接：指向运行时常量池的方法引用，方法返回地址，局部变量表
- 局部变量表
- 方法或函数如何调用
### 本地方法栈
- 栈帧 

### 堆

### 方法区
    - 为什么将永生代替换为元空间
    - 运行时常量池


- 直接内存


#### Java对象的创建过程
- 类加载检查
- 分配内存
    - 内存分配的两种方式：指针碰撞和空闲列表
      - 指针碰撞
      - 空闲列表
    - 内存分配并发问题
- 初始化零值
- 设置对象头
- 执行init方法


#### 对象的内存布局
对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。

对象头占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。

类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。

实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。

对齐填充不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。

#### 对象的访问定位有哪两种方式？
- 使用句柄
- 直接指针

#### String类和常量池

### JMM
- 所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。
- 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
- 线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。
- 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。

### as-if-serial
不管怎么重排序，单线程下的执行结果不能被改变
# 类加载过程

### 类的生命周期
- **加载-连接-初始化**
- **加载-验证-准备-解析-初始化**


#### 类的加载
1. 通过一个类的全限定名来获取其定义的二进制流
2. **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构**
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

- 该阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需的格式存储在存储在方法区之中，而且在java堆中也创建了一个`java.lang.Class`类的对象，这样就可以通过该对象访问方法区中的这些数据。
- JVM允许类加载器预先加载类，但是碰到.class文件缺失或存在错误，要等到程序首次主动使用此类才报错，一直不被使用一直不报错。
- 加载类的方式：本地系统加载，网络下载.class文件，zip、jar中加载，从专有数据库中提取.class文件，将java源文件编译成.class文件。


#### 验证
- 确保class文件的字节流中包含的信息符号符合当前虚拟机的要求，并不会危害虚拟机自身的安全。
1. 文件格式验证：验证字节流是否符合Class文件格式的规范，开头是否是0xCAFEBABE，主次版本号是否在虚拟机的处理范围之内，常量池中的数据类型是否有不被支持的。
2. 元数据验证：对字节码描述的信息进行语义分析，以保证描述的信息符合java语言描述的要求。
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。
4. 符号引用验证：确保解析动作能正确执行。


#### 准备
- 为类的静态变量分配内存和初始化为默认值，**这些内存都将在方法区中分配**
    1. 这时候进行内存分配的仅为类变量，不包括实例变量，**实例变量会在对象实例化时随着对象一起分配在Java堆中**
    2. 初始值通常情况下是数据类型默认的零值，不是被在Java代码中被显式地赋的值。显式赋的值在初始化阶段才会执行。

- 对于局部变量，必须显示的赋值，否则编译时不通过。
- 对于同时被static和final定义的变量，声明的时候必须显式的赋值。只被final修饰的变量可以在声明时显式的赋值，也可以在类初始化的时候显式的赋值。
- 对于引用数据类型reference，如数组引用、对象引用等，如果没有显式的赋值而直接使用，系统默认为零值
- 数组初始化时没有对数组中的各元素赋值，默认零值


#### 解析
- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
- 符号引用就是一组符号来描述目标，可以是任何字面量
- 直接引用直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄

#### 初始化
- 真正执行类中定义的Java程序代码(字节码)，初始化阶段是在执行初始化方法\<clinit>()方法的过程。
- 对于\<clinit>()方法的调用，虚拟机会确保自己在多线程环境中的安全性，是带锁线程安全，所以在多线程环境下进行类初始化可能会引起死锁。
- 主要对类变量进行初始化
- 初始化步骤:
    1. 假设这个类还没有被加载和连接，则程序先加载并连接该类
    2. 假设该类的父类还没有被初始化，先初始化其直接父类
    3. 假设类中有初始化语句，系统依次执行这个初始化语句

- 类初始化时机：只有对类的主动使用的时候才会导致类的初始化
    1. 当遇到new、getstatic、putstatic、invokestatic时。
    2. 初始化某个类的子类，该类父类会被初始化。
    3. 反射机制
    4. 虚拟机启动时被表明为启动类的类

#### 卸载
- 系统自带的类加载器(BootstrapClassLoader、ExtClassLoader、AppClassLoader)的实例不会被回收的，程序员自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

- 卸载需要满足的要求：
    1. 该类中所有实例对象都被GC，堆中不存在该类的实例对象
    2. 该类没有在任何地方被引用
    3. 该类的类加载器的实例已被GC

### JVM类加载机制

#### 类加载机制
- 全盘负责：当一个类加载器负责加载某个类时，该类所依赖和引用的其他的class也要由该类加载器进行加载，除非显示使用另一个类加载器来载入。
- 父类委托：先让父类加载器尝试加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
- 缓存机制：保证所有被加载过的类都会被缓存，当程序需要使用某个类时，首先去缓存区中寻找该类，如果没有找到才去加载二进制数据，转换成class对象，存入缓存区。
- 双亲委派机制：如果一个类加载器收到类加载的请求，首先不会自己去尝试加载这个类，而是把请求委托加载给父加载器去完成。所有类加载请求都会到顶层的启动类加载器中，只有当父加载器无法加载该类时，子加载器才会去自己加载该类。

#### 双亲委派机制过程
1. 当AppClassLoader加载一个class时，它不会自己去尝试加载某个类，而是将类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它不会自己去尝试加载某个类，而是将类加载请求委派给父类加载器BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败，会使用ExtClassLoader去尝试加载。
4. 如果ExtClassLoader也加载失败，会使用AppClassLoader去尝试加载。如果加载失败，会报出ClassNotFoundException异常。

#### 双亲委派机制的好处
- 保证了app的稳定运行，避免了类被重复加载，也保证了java的核心api不被篡改。
#### 什么时候会打破双亲委派模型？
1. jdk中的基础类作为用户典型的api被调用，但是也存在被api调用用户的代码的情况。
2. SPI机制简介 SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中。简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。
3. 使用线程上下文类加载器，在jdbc的使用中，获取jdbc.drivers的属性，得到类的路径，然后通过系统类加载器加载，这时候系统类加载器加载了应用类加载器应该加载的类。
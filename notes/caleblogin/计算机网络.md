# 计算机网络面试

<!--ts-->
- [计算机网络面试](#计算机网络面试)
  - [计算机网络的五层架构](#计算机网络的五层架构)
  - [计算机网络为什么要分层](#计算机网络为什么要分层)
  - [应用层](#应用层)
    - [DNS域名系统](#dns域名系统)
    - [FTP(文件传输协议)](#ftp文件传输协议)
    - [DHCP(动态主机配置协议)](#dhcp动态主机配置协议)
    - [Web页面请求过程](#web页面请求过程)
    - [重定向与转发](#重定向与转发)
    - [HTTP / HTTPS](#http--https)
    - [TCP的三次握手](#tcp的三次握手)
    - [延迟ACK的原因](#延迟ack的原因)
    - [三次握手的原因](#三次握手的原因)
    - [什么是半连接队列](#什么是半连接队列)
    - [全连接队列](#全连接队列)
    - [ISN(初始序号)](#isn初始序号)
    - [三次握手可以携带数据么](#三次握手可以携带数据么)
    - [SYN攻击是什么？](#syn攻击是什么)
    - [TCP三次握手的优化](#tcp三次握手的优化)
    - [TCP四次挥手](#tcp四次挥手)
    - [四次挥手的原因](#四次挥手的原因)
    - [第二次和第三次为什么不能合并？](#第二次和第三次为什么不能合并)
    - [为什么会有TIME-WAIT状态(MSL 报文段最大生存时间)](#为什么会有time-wait状态msl-报文段最大生存时间)
    - [TCP可靠传输](#tcp可靠传输)
    - [TCP滑动窗口](#tcp滑动窗口)
    - [TCP流量控制](#tcp流量控制)
    - [TCP拥塞控制](#tcp拥塞控制)
    - [ARQ协议(自动重传请求)](#arq协议自动重传请求)
      - [停止等待ARQ协议](#停止等待arq协议)
      - [连续ARQ协议](#连续arq协议)
    - [TCP与UDP的比较](#tcp与udp的比较)
    - [UDP实现可靠连接](#udp实现可靠连接)
    - [TCP粘包拆包问题](#tcp粘包拆包问题)
      - [什么是粘包？](#什么是粘包)
      - [TCP粘包是怎么产生的？](#tcp粘包是怎么产生的)
      - [怎么解决粘包](#怎么解决粘包)
  - [网络层](#网络层)
    - [IP协议](#ip协议)
      - [组网划分](#组网划分)
    - [ARP协议：地址解析协议](#arp协议地址解析协议)
    - [ARP欺骗](#arp欺骗)
    - [RARP反向地址解析协议](#rarp反向地址解析协议)
    - [ICMP协议](#icmp协议)
      - [Ping](#ping)
      - [traceroute](#traceroute)
  - [数据链路层](#数据链路层)
  - [物理层](#物理层)

<!-- Added by: hanzhigang, at: 2021年 8月17日 星期二 13时49分57秒 CST -->

<!--te-->

## 计算机网络的五层架构
- 应用层：用户的实际应用多种多样，这就要求应用层采取不同的应用协议来解决不同类型的应用要求。
- 传输层：为端到端提供可靠的传输服务（为不同主机的进程间提供通信服务），为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。
- 网络层：把网络层的协议数据单元从源端传到目的端，为分组交换网上的不同主机提供通信服务。对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。
- 数据链路层：将网络层传来的IP数据包组装成帧。差错控制、流量控制和传输管理等。
- 物理层：在物理媒体上为数据端设备透明的传输原始比特流。


## 计算机网络为什么要分层
1. 各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；
2. 灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响； 
3. 易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化

## 应用层
- 常见使用TCP协议的应用服务：**HTTP、SMTP、POP3、FTP文本传送协议**
- 常见使用UDP协议的应用服务：**DHCP、NTP、TFTP**
- 同时使用TCP、UDP的应用服务：**SOCKS安全套接字协议、DNS地址解析协议**
### DNS域名系统
- 分布式数据库，提供了IP地址和主机名之间相互转换的服务。
- 根域名服务器、顶级域名服务器、权威DNS域名服务器
- 本地域名服务器：当主机和ISP(互联网服务提供商)服务器进行连接时，该ISP会提供一台主体的IP地址，该主机会具有一台或者多台其本地DNS服务器的IP地址。通过访问网络连接，用户能够容易的确定DNS服务器的IP地址。当主机发出DNS请求后，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次系统中。
- 首先请求会先找到本地DNS服务器来查询是否包含IP地址，如果本地DNS无法查询到目标IP地址，就会向根域名服务器发出一个DNS查询。DNS涉及两种查询方式：递归查询和迭代查询。如果根域名服务器无法告知本地DNS服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询。如果根域名服务器能够告知DNS服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。在由根域名服务器 -> 顶级域名服务器 -> 权威DNS服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。
- 可以使用TCP或UDP协议，默认端口为`53`，大部分情况下使用UDP进行传输，当主机域名服务器向辅助域名服务器传送变化的那部分数据或者返回的响应超过512字节时，使用TCP传输。
### FTP(文件传输协议)
### DHCP(动态主机配置协议)
- 配置IP地址，DNS服务器的IP地址，子网掩码、网关IP地址
### Web页面请求过程
1. **DHCP配置主机协议** 
当一台主机还没有分配IP地址时，主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的**UDP报文段**中。该报文段被放入一个具有广播IP目的地址和源IP目的地址的IP数据报中，该数据报被放置到MAC帧中，并广播到与交换机连接的所有设备。当与交换机相连的DHCP服务器收到广播帧后，将广播帧一层一层向上剖析，得到IP数据报、UDP报文段、DHCP请求报文，之后服务器生成DHCP ACK报文，**该报文包括IP地址、DNS服务器的IP地址、默认网关路由器的IP地址和子网掩码**。然后被放到UDP报文段中，接着放到IP数据报中，最后放入到MAC帧中。因为交换机具有自学习能力，交换机记录了MAC地址到其转发接口的交换机表项，因此这时候交换机知道应该向哪个端口进行转发。主机收到后，不断剖析得到DHCP报文，配置它的IP地址、子网掩码和DNS服务器的IP地址，并在IP转发表中安装默认网关。
2. **ARP解析MAC地址**
主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成套接字，需要知道网站的域名对应的IP地址。主机生成一个DNS查询报文，该DNS查询报文被放入目的地址为DNS服务器IP地址的IP数据报中。IP数据报被放入以太网帧中，该帧将被发送到网关路由器。DHCP过程中，只知道网关路由器的IP地址，不知道网关路由器的MAC地址，则主机生成一个包含网关路由器IP地址的ARP查询报文，被放入到一个具有广播目的地址的以太网帧中，并向交换机发送以太网帧，交换机收到以太网帧后转发给所有连接的设备，包括网关路由器。网关路由器在收到以太网帧后不断分解得到ARP查询报文，发现其中的IP地址与其接口的IP地址匹配，则生成ARP回答报文，包含了它的MAC地址，发送回主机。
3. **DNS域名解析**
主机在收到网关路由器发送回来的MAC地址后，就可以继续DNS解析过程了。当网关路由器收到主机的发送的包含DNS查询报文的以太网帧后，抽取出IP数据报，并决定该数据报应该发送给的路由器。到达DNS服务器之后，DNS解析得到DNS查询报文，在DNS数据库中查找出相应的记录后，发送DNS回答报文，把DNS回答报文放入UDP报文段中，接着放入IP数据报中，通过路由器反向转发回网关路由器，并通过以太网交换机达到主机。
4. **HTTP请求页面**
主机在得到IP地址后，生成TCP套接字，并向Web服务器发送Http Get报文。在生成套接字之前必须经过三次握手，在连接建立之后，浏览器生成HTTP GET 报文，并交付给HTTP服务器，HTTP服务器通过TCP套接字读取HTTP GET报文，生成一个HTTP响应报文，将Web页面放入报文主体中，发回给主机。浏览器收到HTTP响应报文，抽取出Web页面，之后进行渲染，显示Web页面。

 ### 重定向与转发
 1. 重定向：客户端行为，两次请求，显示新的地址，请求域中数据会丢失。
 2. 转发：服务器行为，只有一次请求，地址栏不会变化，请求域中数据不会丢失。

### HTTP / HTTPS
1. 长连接和短连接：Connection：keep-alive，1.1之前默认是短连接，之后默认是长连接
2. 状态码
    * 1xx：正在处理
    * 2xx：成功
    * 3xx：重定向码，需要进行附加操作以完成请求
    * 4xx：服务器无法处理请求
    * 5xx：服务器处理请求出错
3. SSL/TSL四次握手
    1. ClientHello：客户端生成随机数Client random，并且携带着支持的TLS版本号以及加密套件的方式发送给服务器，服务器判断是否可用支持的加密方式，如果版本号+加密方式可用，继续进行
    2. ServerHello：服务端生成第二个随机数Server random，携带着SSL证书和服务器选择的密码套件发送给客户端，客户端判断是否可用，可用继续进行
    3. 认证：客户端的证书颁发机构会认证SSL证书，然后发送认证报文，报文中包含公开密钥证书。最后服务器发送`ServerHelloDone`作为hello请求的响应。第一部分握手阶段结束。
    4. 加密阶段：客户端收到服务端的回复后，发送Premaster secret的密钥字符串，这个字符串就是利用服务端的公钥进行加密的字符串，告诉服务端使用私钥解密这个字符串。然后客户端发送`Finished`告诉服务端自己发送完成了
    5. 服务端收到第三个随机数，并利用私钥进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链路数据传输的一个对话密钥。
4. Cookie、Session
    * HTTP是不保存状态的协议，不对请求和响应之间的通信状态进行保存
    * Session
      * 通过服务端记录用户的状态
      * 服务端通过创建一个特定的Session之后就可以标示这个用户，并跟踪这个用户
      * 服务端一般将Session保存在内存或数据库中(Redis)
      * 通过Cookie中附加一个Session ID来进行跟踪用户
    * Cookie
      * 都是用来跟踪浏览器用户身份的会话方式。
      * 一般用来保存用户的信息
      * 会话状态管理、个性化设置、浏览器行为跟踪
    * Token
      * token的组成部分：头部：类型及其签名使用的算法。载荷：该JWT的签发者、该JWT所面向的用户、接收JWT的一方，什么时候过期，在什么时候签发的。签名：将头部和载荷分别进行BASE64编码之后得到两个字符串，然后再将两个字符串用英文句号连接在一起，之后用头部的算法将拼接后的字符串进行加密。
      * 优点：①可扩展性好，应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存放在数据库或者redis里面。而jwt不需要。②无状态，jwt不在服务器端存储任何状态。
      * 缺点：①安全性，因为载荷使用base64编码，并没有加密，因此jwt中不能存储敏感信息。而session存储在服务端相对来说安全一些。②性能：jwt太长，所有数据都放在jwt中，经过编码之后的jwt非常长，cookie的限制一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。每次请求都会带上jwt，导致请求的头部比body还要大，而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用sessionId的开销大得多。③一次性：jwt是一次性的，想修改里面的内容必须重新签发一个jwt。
    * Session和Token的对比
      * 区别：用户状态保存的位置不同，session保存在服务端，jwt保存在客户端。
5. URI、URL
    * URL：统一资源定位符：是URI的子集
    * URI：统一资源标示符
6. HTTPS
    1. HTTP有安全问题：使用明文通信，内容可能被窃听。不验证通信方的身份，通信方的身份可能遭到伪装。无法证明报文的完整性，报文可能被篡改
    2. HTTPS：先让HTTP和SSL(Secure Sockets Layer)通信，SSL再和TCP通信，这样，HTTPS有了加密，认证和完整性保护
        * 加密：非对称加密方式进行通信：通信发送方在收到接收方的公开密钥之后，使用公开密钥对通信内容进行加密，接收方在收到通信内容后，用自己的私有密钥进行解密，得到通信内容
        * 认证：数字证书认证机构 (CA)，服务器运行人员向CA提出公开密钥的申请，CA在判明身份后，会对已签名的公开密钥对数字签名，然后分配这个已签名的公开密钥，与公开密钥证书绑定在一起。服务器会把证书发送给客户端，客户端在收到公开密钥后，先使用数字签名进行验证，如果验证成功就可以通信了。
        * 完整性保护：有了加密和认证这两个机制，就可以形成完整性保护
非对称加密的签名过程是，私钥将一段消息进行加签，然后将签名部分和消息本身一起发送给对方，收到消息后对签名部分利用公钥验签，如果验签出来的内容和消息本身一致，表明消息没有被篡改。

7. HTTP的消息结构
- 请求消息的结构：一个请求消息是由**请求行、请求头字段、一个空行和消息主体**构成。
- 响应消息的结构：状态行，消息报头，空行，响应正文

8. HTTP状态码
200：请求成功。500：程序错误，请求的网页程序本身就报错了。404：服务器上没有该资源，或者服务器上没有找到客户端请求的资源。
301：永久性的重定向。302：临时跳转。304：被请求的资源内容没有发生更改。
400：包含语法错误，无法被服务器解析。403：服务器已经接受请求，但是被拒绝执行。404：请求失败
500：服务器内部错误，无法处理请求。

9. HTTP1.0 与 HTTP1.1的区别
HTTP/1.1 相比 HTTP/1.0 性能上的改进：使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；发送冗长的首部。每次互相发送相同的首部造成的浪费较多；服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；没有请求优先级控制；请求只能从客户端开始，服务器只能被动响应。

10. HTTP和HTTPS的区别
    1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
    2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
    3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
    4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

11. HTTP缓存
12. get post put的概念区别
- get 方法一般用于请求，比如你在浏览器地址栏输入 www.cxuanblog.com 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于表单的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。
- put客户端向服务端传输文件
- 安全和幂等的概念：安全是请求方法不会破坏服务器上的资源。幂等是多次执行相同的操作，结果都是相同的。
- get方法是安全幂等的，post方法不是安全和幂等的。
12. HTTP1.0和HTTP1.1的比较
- 使用TCP长连接的方式改善了1.0短连接造成的性能开销。
- 支持管道网络传输，只要第一个请求发送出去了，不必等待其回来，就可以发第二个请求出去，可以减少整体的响应时间。
- 缺点：头部未经压缩就发送出去，首部信息较多延迟越大，只能压缩body部分。发送冗长的头部，每次互相发送相同的头部造成的浪费较多。服务器是按照请求的顺序响应的，如果响应慢，会导致客户端一直请求不到数据，队头阻塞。没有请求优先级控制。请求只能从客户端开始，服务器只能被动的响应。
13. HTTP1.1和HTTP2.0的比较
- 使用HPACK算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送相同字段了，只发送索引号。头部压缩
- 二进制格式，增加了数据传输的效率。
- 数据流：数据包不是按顺序发送的，同一个连接里面连续的数据包可能属于不同的回应。因此必须要对数据包做标记，指出它属于哪个回应。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。
- 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
- 一个连接中并发多个请求或回应，而不是按照顺序一一对应。不需要排队等待，降低了延迟，避免了队头阻塞的问题，大幅度提高了连接的利用率。
- 服务器推送。
- 缺点：因为多个HTTP请求在复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的，如果发生了丢包，就会触发TCP的重传机制，这样在一个TCP连接中的所有HTTP请求都必须等待这个丢了的包被重传回来。
14. HTTP2.0和HTTP3.0的比较
- 基于HTTP2.0的问题，HTTP3.0把HTTP下层的TCP改成了UDP。基于UDP的QUIC协议可以实现类似TCP的可靠传输协议。
- QUIC有自己的一套机制可以保证传输的可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。
- TLS升级成最新的1.3版本，头部压缩算法也升级成了QPack。
- HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TSL/1.3的三次握手。QUIC直接把以往的TCP和TLS/1.3的6次交互合并成了3次，减少了交互次数。
15. HTTP常见的请求头
- 通用标头：Date(创建报文的日期时间)，Cache-Control(控制缓存的行为)，Connection(持久性连接、非持久性连接)
- 实体标头：Content-Encoding(编码方式)，Content-Language(客户端或服务端能够接受的语言)，Content-Length(实体主体的大小)，Content-Type(媒体类型),Expires(实体主题过期的日期时间),Last-Modified(资源最后修改日期时间)。
- 请求标头：Accept(用户代理可处理的媒体类型)，Accept-Charset(优先的字符集)，Accept-Encoding(优先的内容编码)，If-Modified-Since(比较资源的更新时间，200，304)，If-None-Match(比较实体标记)。
- 响应标头：Keep-Alive(Connection非持久连接的存活时间，可以进行指定)，ETag(资源的匹配信息)。

### TCP的三次握手
A为客户端、B为服务端
- 首先B处于监听状态，等待客户端的连接
- A发送SYN=1，ACK=0的连接请求报文，选择一个初始序号x
- B收到请求连接报文，向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始序号y
- A收到B的连接确认报文后，向B发送确认报文，确认号为y+1，序号为x+1

### 延迟ACK的原因
ACK是可以合并的，如果连续收到2个TCP包，只需要回复最终的ACK就可以了，可以降低网络流量。
如果接收方有数据要发送，就会放到发送数据的TCP包里，带上ACK信息，这样就避免了大量重复的ACK以单独的包发送，减少了网络流量。

### 三次握手的原因
第三次握手是为了防止丢失的连接请求到达服务器，让服务器错误的打开连接。

客户端发送的连接请求如果因为网络问题在网络中滞留，这时客户端等待一个超时重传时间之后，会向服务器重新发送连接请求。如果这个滞留的请求最终到达服务器，如果没有第三次握手，服务器就会再次建立一个连接，存在第三次握手客户端就会忽略服务器之后发送的确认连接报文，不进行第二次第三次握手，这样连接就不会建立。

进行三次握手的主要作用是为了确认双方的接收能力正常和发送能力正常。 

### 什么是半连接队列
当服务器第一次收到客户端的SYN时，处于SYN_RCVD状态，此时双方还没有完全建立链接，服务器会把这种状态的请求放在一个队列里。

### 全连接队列
已经完成三次握手，建立起连接的就是放在全连接队列中，如果队列满了会有出现丢包的现象。

### ISN(初始序号)
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同ISN。ISN可以看作是一个32bit的计数器，每4ms加1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的另一方对它作出错误的解释。
三次握手最重要的一个功能就是客户端和服务端交换ISN，以便让对方知道接下来接收数据的时候如何按照序号组装数据。

### 三次握手可以携带数据么
第三次可以携带数据。

### SYN攻击是什么？
服务端的资源分配是在第二次握手的时候，而客户端的资源分配是在完成三次握手时分配的，所以服务器更容易受到SYN泛洪攻击。
在短时间内伪造大量的不存在的IP地址，并向服务器发送SYN包，服务器则回复确认包，并等待客户端确认，由于源地址不存在，因此服务器不断的重发直到超时，这些伪造的SYN包长时间的存放在半连接队列中，导致半连接队列满，最后导致正常的SYN包被丢弃。从而引起网络拥塞甚至系统瘫痪。


### TCP三次握手的优化
<a href="https://zhuanlan.zhihu.com/p/198089844">参考链接</a>

**客户端的优化**
当客户端在等待服务端的ACK回复的时候，如果等待超时，则会重发SYN，重发次数默认为6次，第一次重发发生在1秒后，接下来的重发时间间隔以翻倍的方式增加，一共经历127秒后，才会终止三次握手。这时可以根据网络的稳定性和服务器的繁忙程度修改重试次数，调整三次握手的时间上限。比如在内网中通讯时，可以减少重发次数，尽快把错误暴露给客户端。
**服务端的优化**
在回复SYN+ACK时，服务器端会将未完成的握手信息放到半连接队列中，如果队列溢出SYN报文会丢失，导致连接失败，我们可以根据netstat -s 给出的统计信息判断队列长度是否合适，进而调整队列的长度。在收到ack时，服务器端会连接移入accept队列中，如果accept队列溢出，系统会丢弃ACK，可以通过netstat -s 给出的统计信息查看accept队列长度是否合适，可以适当调节队列的上限。

在服务器回复SYN+ACK时，若超时将重发SYN+ACK，网络稳定时SYN+ACK的重试次数可以降低。另外为了应付SYN泛洪攻击，应将tcp_syncookies的参数设为1，它在半连接队列满时，将开启syncookies功能，服务器根据状态计算出一个值，放在SYN+ACK的报文中，客户端在返回ACK时也会将该值返回，如果合法则认证建立成功。
**TFO绕过三次握手**
在首次连接建立时，客户端的SYN会明确告诉服务端自己想使用TFO功能，服务端在收到该请求后，会把客户端的ip地址用自己知道的密钥加密，作为Cookie携带在SYN+ACK中，客户端收到后会将Cookie保存到本地。当再次向服务端发送建立连接请求时，就可以在第一次SYN报文中携带数据，并附带Cookie，当服务端验证Cookie合法时，会直接建立成功，并把请求发给进程处理。


### TCP四次挥手
- A发送释放报文，FIN=1，**A进入FIN-WAIT1状态**
- B收到释放报文后，发出确认，此时TCP处于半关闭状态，B能向A发送数据，但是A不能向B发送数据，**A进入FIN-WAIT2状态，B进入CLOSE-WAIT状态**
- 当B不再需要连接的时候，B发送释放报文，FIN=1。**B进入LAST-ACK状态**
- A收到后发出确认，并进入TIME-WAIT状态，等待2MSL(最大报文存活时间)后释放连接。**A进入TIME-WAIT状态**
- B收到A的确认后释放连接。


### 四次挥手的原因
客户端发出连接释放报文之后就入了CLOSED-WAIT状态，这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕后，服务器会发送FIN连接释放报文。

### 第二次和第三次为什么不能合并？
当服务器执行完第二次挥手后，服务端可能还需要向客户端发送数据，所以此时服务端会等待把之前未传完的数据传输完毕后再发送关闭请求。

### 为什么会有TIME-WAIT状态(MSL 报文段最大生存时间)
客户端在收到服务端的FIN连接释放报文后，不会立刻进入CLOSED状态，而是会等待2MSL后再释放连接，理由如下：
- 确保客户端最后发出的确认报文能够到达服务端，如果没有到达服务端，服务端会重新发送连接释放请求报文，A等待时间就是为了防止这种事情发生。
- 为了让本次连接持续时间内产生的所有报文都在网络中消失，使得下一次新的连接不会产生旧的连接请求报文。(比如服务端在发送连接释放请求报文前，还发送了一次数据，结果这次数据在网络中滞留了，连接释放请求报文提前到达，为了不让这次滞留的数据出现在下一次新的连接中，要么等待接收它，要么等待这次请求数据死亡)。

### TCP可靠传输
1. 应用程序被分割成TCP认为最合适发送的报文段
2. TCP对每个包进行编号，接收端对包进行排序，然后将有序的数据发送应用层
3. 校验和：TCP保持它的首部与所携带的数据的校验和，如果传输过程中数据发生变化，校验和会有差错，TCP将会丢弃该报文段
4. TCP丢弃重复的报文段
5. 流量控制：TCP连接的双方都会有一定的缓冲区，当接收方来不及处理发送方发来的数据时，会在返回确认的报文中携带能够容纳的数据的缓冲区大小，提示发送方降低发送的速率，防止包丢失。采用了滑动窗口协议。
6. 拥塞控制(慢开始、快速避免、快重传、快恢复)
7. ARQ协议：发完一个分组就停止发送，等待对方确认再接着发送。
8. 超时重传

### TCP滑动窗口
TCP连接的双方都会有一定的缓冲区，发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口大小来告诉发送方自己的窗口大小，发送方根据这个值和其他信息来设计自己的窗口大小。

发送方窗口内的字节都允许被发送，接收方窗口内的字节都允许被接收。如果发送方的左部字节已经发送并得到了确认，发送方的窗口就向右滑动一段距离。接收方的左部字节已经发送确认并交付主机，就向右滑动一段距离。

接收方的滑动窗口只会对窗口内的最后一个按序到达的字节进行确认，比如收到字节为{31,33,34}，只会对31进行确认，接收方发送ack=32，发送方得到一个字节确认之后，**就会知道该字节之前的字节都已经被接收。**

### TCP流量控制
流量控制是为了控制对方发送的速率，保证接收方来得及接收。为了防止发送方填满接收方的缓冲区。

### TCP拥塞控制
1. 拥塞窗口(cwnd)：状态变量，防止发送方的数据填满整个网络。
2. 慢开始和拥塞避免
发送的最初执行慢开始，cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd加倍。
由于慢开始到后面会使得cwnd增长的越来越快，会使得网络拥塞的可能性更高，所以设置一个ssthresh，当增长的cwnd>=ssthresh时，cwnd之后每次增长的次数变为1，当出现超时时，重新执行慢开始，ssthresh设为上次超时cwnd的一半，cwnd从1开始。
3. 快重传和快恢复
快重传和快恢复是指cwnd的设定值，而不是cwnd的增长率，慢开始cwnd设定为1，快恢复的cwnd = cwnd / 2, ssthresh = cwnd。
接收方只对窗口内最后一个有序到达的报文段进行确认，例如收到{31,33,34}，只会对31进行确认。当发送方连续收到三个重复确认，则判断下一个报文段丢失，立刻进行重传。**快重传：在这种情况下，只是丢失个别报文段，不是出现拥塞，则会将ssthresh设置为cwnd/2，cwnd=ssthresh，进入快速恢复算法。快恢复：cwnd = ssthresh + 3，重传丢失的数据包，如果接收到重复的ACK，那么cwnd+1，如果接收到新数据的ack，cwnd = ssthresh，直接进入拥塞避免。**

### ARQ协议(自动重传请求)
#### 停止等待ARQ协议
- 每发完一个分组就停止发送，等到确认。如果过了一段时间还是没有收到ACK，则重新发送该分组。
- 在停止等待协议中，接收方收到了重复分组，会丢弃重复分组，但还是要发送ACK。

**优点：** 简单。
**缺点：** 信道利用率低，等待时间长。
**分三种情况：** (1)无差错情况 (2)出现差错情况 (3)确认丢失和确认迟到

#### 连续ARQ协议
- 发送方维护一个发送窗口，不需要等待接收方的ACK，发送方中发送窗口中的分组可以连续发送出去，采用累计确认的方式。

**优点** 信道利用率高，容易实现，即使确认丢失，也不必重传
**缺点** 接收方不能正确反映出已经正确接收的所有分组的信息。比如当第三个分组丢失时，接收方只返回前两个分组接收成功，这时发送方要发送第三个分组及之后的所有分组。


### TCP与UDP的比较
1. TCP是面向连接的，可靠的的传输协议，有流量控制、拥塞控制，提供全双工通信、面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不一的数据块)，点对点交互通信
2. UDP是无连接的，尽最大可能交付的，没有拥塞控制、面向报文(对应用程序传下来的报文不合并也不拆分，只添加UDP首部)，支持一对一、一对多、多对多的交互通信。
3. UDP首部8字节，包括源端口、目的端口、长度、检验和。12字节的伪首部：源IP地址、目的IP地址、0、17、UDP长度。
4. TCP首部20～60个字节，包括源端口，目的端口，序号，确认号，数据偏移，确认ACK，同步SYN，终止FIN，窗口

### UDP实现可靠连接
1. 添加seq/ack机制，保证数据发送到对端
2. 添加发送和接收缓冲区，主要是用户超时重传
3. 添加超时重传机制

- 发送端发送数据时，随机生成一个seq=x.然后将每一片的按照数据大小分配seq。数据达到接收端后接收端发入缓存，并发送一个ack=x的包，当发送端收到ack后，删除缓冲区对应的数据。时间到后，定期检查任务是否需要超时重传数据。


### TCP粘包拆包问题
#### 什么是粘包？

客户端可以不断的向服务端发送数据，服务端在接收数据的时候就会出现两个数据报粘在一起的情况。
1. TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不一的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界。
2. 从TCP的帧结构也能看出，在TCP的首部没有表示数据长度的字段。
基于这样的情况，才有可能出现粘包或者拆包现象的可能。一个数据包中包含了发送端发送的两个数据包的信息。接收端接收到了两个数据包，这两个数据包要么是不完整的，要么就是多出来一块。

#### TCP粘包是怎么产生的？
- 发送方产生粘包：采用TCP协议传输数据的客户端和服务端经常保持一个长连接的状态，双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于小时，TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送。这个合并的过程就是发生在发送缓冲区中进行的，也就是说数据发送出来的时候就已经是粘包的状态了。

- 接收端产生粘包：当拿数据的速度小于放数据的速度时，我们在程序中调用的读取数据函数不能及时对缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入缓冲区的末尾，等待我们读取数据时就是一个粘包。

#### 怎么解决粘包
1. 特殊字符控制
2. 在包头首部添加数据包的长度。


## 网络层
- 网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只能提供简单灵活的、无连接的、尽最大努力交互的数据报服务。
- 与IP协议配套使用的还有三个协议：`地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP`

### IP协议
- IP数据报的格式：版本、首部长度、区分服务、总长度，标识、标志、片偏移，生存时间、协议、首部检验和，源地址，目的地址
#### 组网划分
### ARP协议：地址解析协议
ARP实现由IP地址得到MAC地址
每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。
如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。
### ARP欺骗

### RARP反向地址解析协议
- 主机向RARP服务器获取自己的IP地址。(必须处于客户端同一子网中)
- MAC地址转换成IP地址
- 在网络上发送一个RARP请求的广播数据包，请求任何收到次请求的RARP服务器分配一个IP地址。RARP服务器在收到请求数据包后，查找RARP表项，查到该MAC地址对应的IP地址，如果存在RARP服务器就给主机发送一个响应数据包，并将次IP地址提供给对方使用。如果不存在，RARP服务器对此不做任何的响应。发送主机利用得到的IP地址进行通信，如果一直没有收到RARP服务器的响应消息，表示初始化失败。
- RARP服务器一般要为多个主机提供硬件地址到IP地址的映射，该映射包含在一个磁盘文件中，而内核一般不读取和分析磁盘文件(ARP服务器在内核中)，所以RARP的功能就由用户进程来提供。更为复杂的是，RARP请求是作为一个特殊类型的以太网数据帧来传送的，其请求是在硬件层面进行广播的，不经过路由器进行转发。RARP请求数据包中没有IP地址，自然就无法通过路由器进行转发。因此路由器是工作在网络层的，网络层的协议是IP协议，ARP请求能够通过路由器进行转发，是因为ARP请求数据包中有IP字段，而RARP中没有该字段。
- RARP和DHCP的区别：RARP是数据链路层实现的，DHCP是应用层实现的，RARP只能实现MAC到IP地址的查询工作，RARP服务器上的MAC和IP地址必须是事先静态配置好的，但DHCP可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等相对复杂的功能。
### ICMP协议
#### Ping
- Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文（类型8），目的主机收到之后会发送 Echo 回答报文（类型0）。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。
1. ping命令执行的时候，首先会创建一个ICMP回送请求报文，类型8，然后ICMP协议将这个数据报连同ip地址一起交给IP层，IP层的协议字段设为 1 表示ICMP协议，然后加入MAC头，如果本地映射表中不知道目的IP地址的MAC地址，会先发送一个ARP请求报文，得到目的IP地址的MAC地址，然后将在数据链路层构建一个数据帧。另一台主机收到后会构建一个回送响应消息包，类型为0，在发送给源主机。
2. 如果在一段时间内没有收到ICMP回送响应消息，则说明主机不可达，否则主机可达。
#### traceroute
1. 故意设置特殊的TTL，来跟踪去往目的地时沿途经过的路由器。
- 利用IP数据报的生存期限，从1开始按照递增顺序的同时发送UDP包，强制接收ICMP超时消息的一种方法。
- 比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同意返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。这样的过程，traceroute 就可以拿到了所有的路由器 IP。当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。
- 发送方如何知道UDP包到达了目的主机：traceroute在发送UDP包时，会填入一个不可能的端口号作为目的地址的端口号，当目的主机接收到ICMP报文后，会回发一个差错报文消息，但这个差错报文的类型是端口不可达。当差错报文的类型是端口不可达时，则说明UDP数据包达到了目的主机。
2. 故意设置不分片，从而确定路径的MTU。
- 为了路径MTU发现。
- 首先在发送端主机发送IP数据报时，将IP包首部的分片禁止标识位设为1。根据这个标识位，途中的路由器不会对大数据报进行分片，而是将包丢弃。随后通过一个ICMP的不可达消息将数据链路上MTU的值一起发送给主机，不可达消息的类型为`需要进行分片但设置了不分片位`。发送主机端每次收到ICMP差错报文时就减少包的大小，以此来定位一个合适的MTU的值，以便能达到目的主机。
## 数据链路层


## 物理层

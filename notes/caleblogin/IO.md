# IO

<!--ts-->
- [IO](#io)
  - [IO模型简介](#io模型简介)
    - [IO分类](#io分类)
      - [java中为什么有了字节流还要有字符流？](#java中为什么有了字节流还要有字符流)
    - [五种IO模型](#五种io模型)
    - [输入操作两个阶段](#输入操作两个阶段)
    - [套接字输入操作](#套接字输入操作)
    - [BIO](#bio)
    - [NIO](#nio)
      - [NIO的特性、NIO与IO的区别](#nio的特性nio与io的区别)
    - [AIO](#aio)
    - [阻塞/非阻塞 异步/同步](#阻塞非阻塞-异步同步)
    - [NIO](#nio-1)
      - [流与块](#流与块)
      - [通道与缓冲区](#通道与缓冲区)
      - [选择器](#选择器)
    - [多路IO复用](#多路io复用)
      - [Reactor模型](#reactor模型)
    - [零拷贝](#零拷贝)
    - [select、poll、epoll](#selectpollepoll)
      - [select](#select)
      - [poll](#poll)
      - [epoll](#epoll)
    - [select、poll、epoll的区别](#selectpollepoll的区别)

<!-- Added by: hanzhigang, at: 2021年 8月17日 星期二 13时51分20秒 CST -->

<!--te-->

## IO模型简介

### IO分类
- 磁盘操作：file
- 字节操作：InputStream和OutputStream
- 字符操作：Reader和Writer
- 对象操作：Serializable
- 网络操作：Socket
#### java中为什么有了字节流还要有字符流？
字节流是java虚拟机将字节转换得到的，这个过程还算是非常耗时，并且如果我们不知道编码类型，就很容易出现乱码问题。所以IO流就直接提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话用字符会比较好。

### 五种IO模型
- 阻塞式IO(BIO)
- 非阻塞式IO(NIO)
- IO复用(select和poll)
- 信号驱动式IO
- 异步IO(AIO)

### 输入操作两个阶段
- 等待数据准备好
- 从内核向进程复制数据

### 套接字输入操作
- 等待数据从网络中达到，当所等待分组到达时，它被复制到内核中的某个缓冲区。
- 把数据从内核缓冲区复制到进程缓冲区。

### BIO
- 同步阻塞IO模式，数据的读取写入必须阻塞在一个线程内等待完成。应用程序被阻塞，直到数据复制到应用程序缓冲区中才返回。
- 这里阻塞过程中，其他程序还可以继续执行。
- 对于十万甚至百万级连接时，传统的BIO模型是无能为力的。
- 一请求一应答通信模型

### NIO
- 同步非阻塞IO模式，在java1.4中引入了NIO框架，对于java.nio包，提供了Channel、Selector、Buffer等抽象。
- 支持面向缓冲区，基于通道的I/O操作方法。
- 提供了`SocketChannel`和`ServerSocketChannel`两种不同的套接字通道实现，也支持阻塞模式，相对于BIO中的`Socket`和`ServerSocket`。
- 非阻塞模式对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发效率和更好的维护性。对于高负载和高并发的应用，使用NIO的非阻塞模式来开发。
#### NIO的特性、NIO与IO的区别
- **IO流是阻塞的，NIO是非阻塞的**
1. 单线程中从通道读取数据到buffer，同时可以继续做别的事情，当在通道中读取到buffer的时候，线程再继续处理数据。
2. 非阻塞写，一个线程写一些数据到通道中，不需要等待它完全写入，就可以去做别的事情。
- **Buffer(缓冲区)**
1. IO是面向流的，NIO是面向缓冲区的
2. Buffer是一个对象，它包含一些要写入或读出的数据。NIO引入了Buffer这个对象，这是和IO一个重要的区别。
3. IO是Stream oriented，虽然Stream也有Buffer开头的扩展类，但是只是流的包装类，最终还是从流到缓冲区。
4. Buffer是直接将数据读到缓冲区中进行处理的。
- **Channel(通道)**
1. 通道是双向的，可读可写，但流的读写是单向的。无论读写，通道都是和Buffer交互。因为Buffer，通道可以异步的读写。
- **Selector(选择器)**
1. NIO有选择器，IO没有选择器
2. 选择器用于单线程处理多个通道。对于操作系统来说，线程之间的切换是比较昂贵的，所以需要使用较少的线程来处理多个通道，所以使用选择器对于提高操作系统的效率是比较有用的。

### AIO
- 异步非阻塞的I/O模型，基于事件和回调机制实现的。

### 阻塞/非阻塞 异步/同步
- 同步和异步是通信机制，阻塞和非阻塞是调用状态。
- 阻塞是在调用revfrom的时候，因为还没有数据准备好，线程阻塞，直到数据准备好再返回。非阻塞是在调用revfrom的时候，不论数据有没有准备好，都返回一个状态码。
- 同步是在数据准备好后，调用revfrom的线程发起系统调用，将数据从内核复制到用户空间。异步是当数据返回好后，主动将数据从内核复制到用户空间。然后返回一个状态码给相应的线程。


### NIO
#### 流与块
- IO与NIO最重要的区别就是数据打包方式和传输方式。IO以流的方式处理数据，而NIO以块的方式处理数据。
- 面向流的IO一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流产生一个字节数据。
- 面向块的IO一次处理一个数据块，按块处理数据比流处理数据要快得多。
#### 通道与缓冲区
- **通道**
通道Channel是对原IO包中流的模拟，可以通过它读取和写入数据。通道和流的不同之处在于通道是双向的，可以用于读或写或者同时读写。流是单向的。
- **缓冲区**
发送给一个通道的所有数据必须先放到缓冲区中，同样的，从通道中读取的任何数据都要先读到缓冲区中，也就是说不会直接对通道进行读写数据，而是要先经过缓冲区。
缓冲状态变量：capacity 最大容量，position 已经读写的字节数，limit 还可以读写的字节数。
缓冲区实际上是一个数组，但它不仅仅是一个数组，缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。
#### 选择器
- **选择器** NIO实现了IO多路复用中的Reactor模型，一个线程Thread使用一个选择器Selector通过轮询的方式监听多个通道Channel上的事件，从而让一个线程就可以处理多个事件。
通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其他Channel，直到IO事件已经到达的Channel执行。
### 多路IO复用
#### Reactor模型
- 并发读写
Reactor分为mainReactor和subReactor，mainReactor主要进行客户端的连接的处理，处理完成之后将该连接交由sunReactor以处理客户端的网络读写。这里的subReactor则是使用一个线程池来支撑的，其读写能力将会随着线程数的增多而大大增加。对于业务操作，则是使用一个线程池，每个业务请求都只需要进行编解码和业务计算。
### 零拷贝
1. mmap + write(两次次系统调用+三次拷贝)
mmap()系统调用函数会直接把内核缓冲区里的数据`映射`到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。
具体过程如下：
- 应用程序调用了mmap()后，DMA会把磁盘的数据拷贝到内核的缓冲区里。接着，应用程序和操作系统`共享`这个缓冲区。
- 应用程序再调用write()，操作系统直接把内核缓冲区的数据拷贝到socket缓冲区中，这一切都发生在内核态，由CPU来搬运数据。
- 最后把内核的socket缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由DMA搬运的。

仍需要通过CPU把内核缓冲区的数据拷贝到socket缓冲区里，仍然需要4次上下文切换，因为系统调用还是2次。

2. sendfile(一次系统调用+三次拷贝)
```c++
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```
前两个参数是目的端和源端的文件描述符，后两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。

它可以替代前面的read()和write()这两个系统调用，这样就可以减少一次系统调用，也就减少了两次上下文切换的开销。

该系统调用可以直接把内核缓冲区里的数据拷贝到socket缓冲区里，不再拷贝到用户态，这样就只有2次上下文切换和3次数据拷贝。

(一次系统调用+两次拷贝)
如果网卡支持SG-DMA技术，可以进一步减少通过CPU把内核缓冲区里的数据拷贝到socket缓冲区的过程。

在linux内核2.4版本开始，对于支持网卡支持SG—DMA技术的情况下，sendfile()系统调用的过程具体如下：
- 第一步：通过DMA将磁盘上的数据拷贝到内核缓冲区里。
- 第二步：缓冲区描述符和数据长度传到socket缓冲区，这样网卡的SG-DMA控制器就可以直接将内核缓冲中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到socket缓冲区中，这样就减少了一次数据拷贝。

3. 大文件使用异步 + 直接IO，不使用零拷贝，因为零拷贝会用到PageCache(磁盘高速缓存)，PageCache主要用来就IO的数据进行合并以及预读。将大文件放到PageCache中会造成大文件很快填满PageCache，造成很多小的热点文件不能被读到。(将数据拷贝到内核缓冲区中，这个内核缓冲区说的就是磁盘高速缓存)。
### select、poll、epoll
#### select
```c++
int select(int maxfdp, fd_set *readset, fd_set *writeset, 
            fd_set *exceptset, struct timeval *timeout);
```
- 基本原理：select函数监视的文件描述符分为三类，writefds，readfds和exceptfds。调用select时会被阻塞，直到有fd就绪或者超时，函数返回一个大于0的值，遍历文件描述符fd_set，来找到就绪的描述符。
- maxfdp是一个整数值，是指集合中所有文件描述符的范围，即所有最大文件描述符+1。fd_set是以位图的形式存储这些文件描述符，maxfdp定义了位图中有效的位的个数。
- 时间复杂度O(n)，n为文件描述符fd_set的大小。文件描述符最大限制1024。
#### poll
```c++
int poll ( struct pollfd * fds, unsigned int nfds, int timeout);
```
- poll定义了一个pollfd结构的数组，用于存放需要检测其状态的所有文件描述符，调用poll的时候不会清空这个数组，特别对于文件描述符比较多的情况，在一定程度上提高了查询的效率。这和select有很大的不同，在每次调用select之后，都会清空它检测的文件描述符集合，导致每次调用select都必须把文件描述符重新加入到待检测的文件描述符集合中。因此select适合只检测一个文件描述符的情况，而poll适合检测大量文件描述符的情况。
- 时间复杂度：O(n)，n是文件描述符集合的大小。文件描述符没有最大限制。
#### epoll
- 将所有文件描述符存储在共享内存中(用户空间和内核空间可以直接访问)。调用epoll_create函数创建epoll对象，并以红黑树的结构存储在内核空间，epoll_ctl函数用来在红黑树中添加或注销监视文件描述符，最后调用epoll_wait函数直到有就绪的文件描述符，立即返回给用户态进程。
- 时间复杂度O(1)，文件描述符最大限制能打开的fd的上限远大于1024。
- epoll的两种工作方式：LT：水平触发，若就绪事件一次没有处理完所有要做的事件，就会一直处理，即就会把没有处理完的事件继续放回就绪队列中，一直进行处理。ET：边缘触发，就绪处理事件只处理一次，若没有处理完，会在下次事件就绪时继续处理。如果后续没有就绪的事件，那么剩余的那部分数据也会随之而丢失。
### select、poll、epoll的区别
1. select 应用场景 select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。
2. poll 应用场景 poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。 需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。 
3. epoll 应用场景 只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。
4. 传递方式：select和poll都是内核到用户，epoll则是共享内存。
5. 在select和poll中，进程只有在调用方法后，内核才对所有监视的文件描述符进行扫描，发现有任何一个文件描述符就绪或者超时，就会立即返回。而epoll则是基于事件的就绪通知方式，事先通过epoll_ctl来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait时就会得到通知。

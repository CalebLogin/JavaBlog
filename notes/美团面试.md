# 美团

## Java基础
1. volatile关键字，线程安全怎么保证
	- 保证可见性和不可排序性。
	- 可见性：总线，嗅探机制，对数据的更新直接强制写会内存，嗅探机制使其他缓存中的该数据直接失效。
	- 插入内存屏障：不管什么指令都不能和这条memory barrier指令重排序。StoreStore，StoreLoad，LoadStore，LoadLoad。后面的v的写和前面的普通写禁止重排序，前面的v写和后面的可能的v读/写禁止重排序，前面的v读和后面的普通写禁止重排序，前面的v读和后面的读禁止重排序
2. 泛型原理，有哪些好处
   - 好处：适用于多种数据类型执行相同的代码（代码复用）
   - 实现原理：类型擦除。java语法上支持泛型，但是在编译期会进行类型擦除，将所有泛型表示都替换成具体的类型。类型擦除的原则：①会消除类型参数声明，删除<>包含的部分。②根据类型上下界推断并替换原生态类型，如果没有上下界约束，将类型擦除为object，如果有上界限制，将类型替换为上届类型，如果有下届限制，将类型替换为object。③为了保证类型安全，必要时插入强制类型转换代码。④自动产生桥接方法，以保证类型擦除后的代码仍具有泛型的多态性。
   - 如何理解泛型的编译器检查：是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的泛型方法进行类型检查，而无关它真正的引用对象。
   - 如何理解泛型的多态，桥方法：泛型擦除会造成多态的冲突，jvm的解决方法就是桥方法。子类真正覆盖的是父类的两个方法是我们看不到的桥方法，桥方法内部只是去调用我们重写的那两个方法。 
3. 四个引用，有啥区别，应用场景
   - 强引用，软引用，弱引用，虚引用。
   - 强引用，任何时候都不会被jvm回收，即使oom。软引用：当内存不足时，会被回收。弱引用：每次gc的时候都会被回收，不管内存是否充足。虚引用：需要和referencequeue联合使用，当jvm扫描到虚引用的对象时，会先将次对象放到关联的队列中，因此我们可以通过判断队列中是否存在该对象，来了解被引用的对象是否将要被回收，进行一些回收前的处理。
   - 使用场景：软引用：创建缓存，弱引用：WeakHashMap类中的key，可以使用WeakHashMap<String,Map<k,v>>保存事务的信息，在事务周期中，String对象的强引用一直存在，我们就一直可以获取信息，当事务结束时，弱引用可以自动帮我们清除map信息。虚引用：用于对象销毁前的一些操作，比如资源释放等。
4. JVM垃圾回收，CMS，G1区别对比
   - 判断一个对象是否会被回收：引用计数法，gc root(可达性分析算法)，方法区的回收，finalize方法 
   - 新生代(伊甸区，幸存区0，幸存区1)，老年代，young gc，major gc，full gc。
   - 标记清除，标记整理，标记复制，分代收集
   - 垃圾回收器：
     - Serial垃圾回收器，只会使用一个线程进行垃圾回收，新生代：复制算法，暂停所有用户线程，老年代：标记整理，暂停所有用户线程。
     - CMS垃圾回收器：初始标记：只是简单地标记一下gc root能关联的对象，时间很短，需要停顿，并发标记：进行GC Root Tracing的过程，耗时最长，不需要停顿，重新标记：修正并发标记期间因用户程序继续运行而产生变动的那一部分对象的标记记录，需要停顿。并发清除：不需要停顿。缺点：吞吐量低，低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高。无法处理浮动垃圾，可能会导致Concurrent Mode Failure。浮动垃圾是指并发清除阶段用户程序继续运行而产生的，只能等到下次GC的时候才能会被回收。由于浮动垃圾的存在，老年代需要预存一段内存，CMS不能像其他垃圾回收器一样等到老年代快满时，再进行垃圾回收。如果预留的空间不足时，可能会导致Concurrent Mode Failure，将临时启用Serial Old来代替CMS。标记-清除算法导致碎片，往往出现老年代剩余，导致无法找到一块连续的足够大的内存空间存放对象，不得不提前触发一次full gc。
     - G1垃圾回收器：其他垃圾回收器都是面向新生代或者老年代，G1可以直接对新生代和老年代一起回收。G1把堆分成多个大小相等的独立区域，新生代和老年代不再物理隔离。对每一个小块进行单独的垃圾回收，这种划分方法带来很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收可获得的空间，并维护一个优先列表，每次根据允许的收集时间，回收价值最大的Region。每个Region都有一个Remembered set，用来记录Region对象的引用所在的Region。通过使用Remembered set，避免在做可达性分析的时候进行全堆扫描。初始标记，并发标记，最终标记，为了修正并发标记期间用户程序继续运行而产生变动的那部分记录，虚拟机将这段时间对象变化记录在线程的Remembered set logs中，最终标记阶段需要把Remebered set logs的数据合并到remembered set中，需要停顿用户线程，但是可以并行执行。筛选回收：首先对region中回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，此阶段也可以做到并发执行，但是因为只回收一部分region，时间是用户可控制的，而且停顿用户线程可以大幅度提高收集效率。特点：空间整合，整体来看是基于标记-整理，局部来看(两个Region)，是基于复制算法，这意味着运行期间不会产生空间碎片。可停顿的预测：能让使用者指定在一个M毫秒的时间内，消耗在GC上的时间不超过N毫秒。
     - 内存分配策略：对象优先在伊甸区，大对象直接在老年代，空间分配担保，长期存活的对象进入老年代，动态对象年龄判定(当幸存区中的同年龄对象总和超过所有对象的一半时，大于等于年龄的对象直接进入老年代)。
5. Full GC什么时候触发
	- System.gc，空间担保失败，Concurrent Mode Failure，老年代空间不足，1.7及之前的永久代空间不足。
6. BlockingQueue
7. 多线程sleep，wait的区别
	- sleep不会释放锁资源，wait会释放锁资源。sleep到时会自动唤醒，wait不带时间的需要其他线程唤醒。带时间的如果没有被notify，自己唤醒，两种情况，直接获得锁，没有获得锁，线程进入同步队列等待获得锁。
8.  可重入锁，Synchronized、Lock
	- 可重入锁：Synchronized通过加锁次数计数器来实现可重入锁，每个对象用于一个计数器，当线程获取该对象锁后，该计数器就会加1。lock通过调用底层的AQS的state值，通过增加state的值来实现可重入锁。
	- Synchronized通过获得对象监视器来实现锁，作用在方法上，代码块，类锁。方法上调用ACC_SYNCHRONIZED，底层还是获得对象监视器。通过查看字节码文件有monitor enter和monitor exit指令，每个对象在同一个时间内只能与一个对象监视器相关联，一个监视器在一个时间点内只能被一个线程获得。
	- Lock：底层基于AQS，默认是非公平锁。
	- 对比：Synchronized基于JVM，lock基于API，Synchronized在异常情况下会释放锁，lock不会释放锁。Synchronized是等待获得锁的过程中是不可被中断的，lock是可以被中断的。Synchronized只能实现非公平锁，lock可以实现公平锁和非公平锁。lock可以绑定多个条件，而Synchronized只能与是否获得锁条件绑定。
9.  ConcurrentHashMap怎么实现线程安全
    - 1.7 Segmemt，lock+CAS
    - 1.8 Synchronized+CAS
10. threadLocal什么场景下使用
11. 线程池参数，核心线程数的选择，怎么调整核心线程数
12. 设计模式，单例模式、工厂模式、桥接模式、装饰器模式
## Redis
1. 数据类型，底层实现
2. 主从同步
3. 持久化
4. AOF重写
5. 哨兵机制
6. redis集群
7. 一致性Hash，扩容缩容怎么实现
8. 缓存穿透，缓存雪崩，缓存击穿，缓存污染
## Spring
1. AOP原理
2. 解释动态代理
3. Spring中的拦截器是怎么实现的
4. SpringMVC请求处理流程
## MySQL
1. 索引
2. InnoDB、MyISAM
3. 主从同步、如何避免主从延迟
4. MySQL读写分离、路由策略、分库分表、取模之后表变化了/扩容了怎么办，怎么实现重新路由
5. MySQL事务隔离级别
6. undo log、redo log、bin log的区别，哪些地方用了
7. B+树，B树区别，节点计算公式
8. 主索引、非主索引
9. 索引方式
10. 常见索引，主键索引、普通索引的区别
11. MySQL缓存如何实现的，SQL缓存，数据缓存
12. Buffer Pool如何实现缓存，Buffer Pool脏数据如何避免，flush刷盘触发动机，change buffer的应用
13. 联合索引，索引覆盖，索引下推，前缀索引的应用场景
14. MySQL MRR机制
15. MySQL多表连接的时候有什么优化点
## ZooKeeper

## RPC

## 分布式事务

## Kafka
1. kafka基本实现原理，和其他的区别
2. zk的作用，offset的作用
3. kafka主本副本
4. leader分区选举策略
5. 如何实现零拷贝
6. 性能优化，kafka为什么这么快
7. pull和push的优缺点
<!-- GFM-TOC -->
- [Token](#token)
  - [Session的认证](#session的认证)
    - [Session的局限性](#session的局限性)
  - [Token流程](#token流程)
  - [JWT结构](#jwt结构)
    - [header(头部)](#header头部)
    - [playload(载荷)](#playload载荷)
    - [signature(签证)](#signature签证)
<!-- GFM-TOC -->
# Token
## Session的认证
因为http是无状态的，所以用户向我们发送用户密码进行用户验证后，下次请求还需要再请求一次才行。为了让我们的应用知道是哪个用户发送的请求，我们只能在服务器存储一份用户登录的信息，这份信息会在响应时发送给浏览器，并保存在cookie。这样下次请求的时候，就知道哪个用户发送的请求了。这就是传统的Session认证
### Session的局限性
1. 经过用户认证之后，都会在服务端做一次记录，通常session是存放在服务端内存中的，随着客户端的增多，服务端的开销会明显增多。
2. 用户认证之后，服务端记录下来，意味着下次请求还必须是请求在这台服务器上，这样才能拿到授权资源。在分布式应用上，限制了负载均衡的能力，也限制了应用的扩展能力。
3. 当在cookie中拿到session后，容易引起跨站请求的伪造的攻击。（CSRF）
## Token流程
* Token是不需要保存用户的认证信息或会话信息的。免去了将信息保存在内存中的困扰。
1. 用户使用用户名密码来请求这台服务器。
2. 服务器进行验证用户信息。
3. 服务器通过验证发送给用户一个token。
4. 客户端存储token，并在每次请求上都加上这个token。
5. 服务端验证token，并返回数据。
## JWT结构
JWT由三段信息构成，这三段文本用`.`来组成一个字符串
### header(头部)
```json
{
    'typ': 'JWT',
    'alg': 'HS256'
}
```
声明类型和加密算法，然后用`BASE64`加密。
### playload(载荷)
存放有效信息的地方
* 标准中注册的声明
* 公共的声明
* 私有的声明
1. 标准中注册的声明
   - **iss**:jwt签发者
   - **sub**:jwt所面向的对象
   - **aud**:接收jwt的一方
   - **exp**:jwt的过期时间，必须要大于签发时间
   - **nbf**:定义在什么时间之前，该jwt都是不可用的
   - **iat**:jwt的签发时间
   - **jti**:jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击
### signature(签证)
签证信息，由三部分组成：
- **header**(BASE64后的)
- **playload**(BASE64后的)
- **secret**

这部分需要加密后的header和加密后的playload使用`.`进行组成字符串，然后通过header中声明的加密方法进行加盐`secret`组合加密。

最后这三部分用`.`组成字符串形成最终的JWT。
# HashMap
### 为什么底层数据结构使用红黑树

### 1.8版本之前的底层实现

### 1.8版本及之后的底层实现

#### put()

1. 在第一次插入的时候先进行resize操作。这次是将数组从null初始到16或指定的初始容量。
2. 如果当前位置没有值，初始化一下节点并放到数组中就可以了。
3. 如果当前有值，如果该节点是红黑树，则按照红黑树的插入方法。如果该节点是链表节点，则尾插法。
4. 在遍历过程中如果到了尾部，则将插入节点插入。如果发现有hash相同的节点，则更新当前节点。
5. 在链表插入过程中，节点插入后如果超出阈值(8)，则将该链表转换成红黑树。
6. 如果由于当前节点的插入导致size超出了阈值，扩容。

#### resize()

- 每次扩容扩容为当前容量的两倍
1. 首先旧表为空的话，旧表容量为0，旧表阈值为当前阈值，新表容量和新表阈值为0。
2. (1)如果旧表容量不为0，则对应数组的扩容。当旧表容量比最大容量还大时，新表容量为整形最大值。如果两倍旧表容量没有超过最大容量并且旧表容量大于等于初始容量，新表容量为两倍旧表容量，新阈值为两倍旧阈值。(2)当初始化自定义容量后，第一次put的时候，新表容量为自定义容量的阈值。(3)当初始化hashmap，使用默认容量的的时候，新表容量为默认初始容量，新表阈值为负载因子 * 默认初始化容量。阈值等于新的阈值。
3. 初始化一个新的数组，长度为newCap。
4. 如果旧数组不为空，遍历旧的数组。(1)如果当前位置只有一个节点，则`newTab[e.hash & (newCap - 1)] = e`，将当前节点放到新表中。(2)如果当前节点是红黑树类型，则进行红黑树分裂的操作。(3)当前节点类型是链表节点类型，新建两个链表，分别为低位链表和高位链表，每个链表对应头节点和尾节点。`(e.hash & oldCap)`计算当前节点在新表中的位置，如果等于0`((e.hash & oldCap) == 0)`，表示当前节点为保留在当前旧表`[j]`位置，尾插入低位链表。如果不等于0`((e.hash & oldCap) != 0)`，则当前节点会保留在新表的`[j + oldCap]`位置，尾插入高位链表。遍历完旧表`[j]`位置的节点后，将低位链表和高位链表存入新表相应位置。
5. 返回新表。


#### 可能出现线程不安全的两个地方
- 多线程环境下put方法导致数据不一致，读写数据不一致
- 在多线程环境下，resize可能会出现回环的情况，造成死循环，环形链表

- 事务
    - 什么是事务
    事务是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。
    - 事务的四大特性
        1. 原子性
        事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些操作即可。
        2. 一致性
        数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结果都是相同的。
        3. 隔离性
        一个事务所做的修改在最终提交之前，对其他事务是不可见的。
        4. 持久性
        一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统崩溃，事务的执行的结果也不能丢失。
    系统发生崩溃，可以用重做日志进行恢复，从而实现持久性。
    - ACID的理解
        只有满足一致性，事务的执行结果才是正确的。
        在无并发的情况下，事务串行执行，隔离性一定能满足。此时只要能满足原子性，就一定能满足一致性。
        在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性才能满足一致性。
        事务持久化是为了能应对系统崩溃的情况。
- 并发一致性问题
    在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性的问题。
    - 丢失修改
        一个事务的更新操作被另一个事务的更新操作替代。比如A修改数据的时候，事务未结束，B就来修改数据，结果导致第一个事务修改的数据丢失
    - 读脏数据
        事务A在进行修改后，事务还未提交，事务B就读到了事务A修改的数据，结果事务A又撤销了修改，事务B读到的数据就是脏数据
    - 不可重复读
        在一个事务A内多次读同一个数据，在这个事务还没有结束的时候，另一个事务对该数据进行了修改操作，导致第一个事务两次读取的结果不太一样。
    - 幻读
        幻读也是不可重复读的一种情况，当一个事务读取了几行数据，接着另一个事务插入了几行数据，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录。比如学生数量原来为5，另一个事务又插入了一名学生，导致再次查询时学生数量变成了6.
- 封锁
    - 封锁的粒度：表级锁和行级锁
    表级锁，粒度最大的一种锁，对当前操作的整张表进行加锁，资源消耗比较少，加锁快，不会出现死锁，发生锁的冲突概率大，并发度低
    行级锁，粒度最小的一种锁，对当前操作的行进行加锁，资源消耗比较大，加锁慢，会出现死锁，但是并发度高。
    - 锁分类：共享锁S（读锁），排他锁X（写锁）意向锁（表锁）（IS,IX）
    一个事务对数据进行读取和更新的时候，需要对这个对象加X锁。
    一个事务对数据进行读取的时候，需要对这个对象加S锁，加锁期间，其他事务想要对这个对象进行操作的时候，只能加S锁，不能加X锁。
    使用意向锁更容易实现多粒度封锁。IX表示希望对这个对象加X锁，IS表示希望对这个对象加S锁。
    S锁只与S锁和IS锁兼容，也就是说事务A想对数据加S锁时，其它事务可以对表或表中饿行加S锁。
    - 封锁协议
        - 三级封锁协议
        1. 一级封锁协议
        事务A想要修改数据，必须加X锁，事务结束才能释放锁。（解决丢失修改问题）
        2. 二级封锁协议
        在一级封锁协议的基础上，事务A想要读数据必须加S锁，读取完马上释放锁。（解决读脏数据问题）
        3. 三级封锁协议
        在二级封锁协议的基础上，事务A想要读数据必须加S锁，事务结束才能释放锁。（解决不可重复读的问题）
        - 两段封锁协议
        加锁和解锁分为两个阶段进行。
        可串行调度：通过并发控制，使得并发执行的事务与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。
- 隔离级别
    - 未提交读
    最低的隔离级别，可能会导致脏读，幻读和不可重复读
    - 提交读
    允许读取已经提交的事务，可以阻止脏读，但不能阻止幻读和不可重复读
    - 可重复读（MySQL默认级别）
    对同一字段的多次读取结果是一样的，除非数据被本身事务自己所修改，可以阻止脏读和不可重复读，可能会导致幻读。
    - 可串性化
    最高的隔离级别，完全服从ACID的隔离级别。
    MySQL的存储引擎InnoDB在可重复读的隔离级别下，使用的是Next-key Lock锁算法，可以避免幻读的产生，已经完全保证事务的隔离性要求。
- 多版本控制
    - 多版本并发控制（MVCC），MVCC是InnoDB存储引擎实现隔离级别的一种方式，实现了提交读和可重复读两种隔离级别。可串性化隔离级别需要对所有读取的行都加锁，单独使用MVCC不能实现。写操作去读最新的版本快照，读操作去读旧的版本快照，没有互斥关系。
    - 版本号
    系统版本号：SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
    事务版本号：TRX_ID：事务开始时的系统版本号。
    MVCC的多版本是指多个版本的快照，快照存放在Undo日志中，该日志通过回滚指针将一个数据行的所有快照连接起来。
    隐藏的列：MVCC在每行记录后面都保存着两个隐藏列，用于保存两个系统版本号。
        创建版本号：创建一个数据行的快照时系统的版本号
        删除版本号：如果该快照的删除版本号大于当前事务版本号表示事务有效，否则表示已经被删除。
    - 实现过程
    当开始一个事务时，当前事务的版本号肯定会大于当前所有行快照的创建版本号。
    1. select
    2. insert 当前系统版本号作为当前快照的创建版本号。
    3. update 当前系统版本号作为更新前的删除版本号，当前系统版本号作为更新后的数据行快照的创建版本号。
    4. delete 当前系统版本号作为当前快照的删除版本号。
- Next-Key Locks
    - InnoDB引擎中的锁的算法：Record lock，Gap lock，next-key lock
    Record lock：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB存储引擎会自动在主键上创建隐藏的聚簇索引，所以Record lock依然可以用。
    Gap lock：锁定索引之间的间隙，但不包含索引本身。
    next-key lock：是Record lock和Gap lock的结合，不仅锁定记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。
- 大表优化
- 
# Redis数据结构

- Redis是什么
    - Redis是C语言开发的开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等。
    - 它是一种非关系型数据库，性能优秀，单进程单线程，是线程安全的，采用IO多路复用机制，丰富的数据类型，支持string、list、hash、set、sorted sets等。支持数据持久化，可以将内存中数据保存到磁盘中，重启时加载。主从复制、哨兵、高可用。可以用作分布式锁，可以作为消息中间件使用，支持发布订阅。

<br>

- Redis是单线程还是多线程
    - Redis4.0之前，redis是完全的单线程
    - Redis4.0引入了多线程，但是额外的线程只能用于后台处理，记录删除对象，核心流程还是完全单线程的。(核心线程指的是Redis正常处理客户端请求的流程，包括接受命令，解析命令，执行命令，返回结果等)
    - Redis6.0 这次引入的多线程的概念会涉及到核心线程。多线程主要用于网络I/O阶段，也就是接收命令和写回结果阶段，而在执行命令阶段，还是由单线程串行执行。(Redis中的多线程组不会同时存在读和写，这个多线程组只会同时读或者同时写)

<br>

- Redis6.0加入多线程I/O之后，处理命令的核心流程如下：
    - 当有读事件到来时，主线程将客户端连接放到全局等待读队列
    - 读取数据：1）主线程将等待读队列的客户端连接通过轮询调度算法分配给I/O线程处理；2）同时主线程也会自己负责处理一个客户端连接的读事件。3）当主线程处理完该连接的读事件后，会自旋等到所有I/O线程处理完毕
    - 命令执行：主线程按照事件被加入全局等待读队列的顺序，串行执行客户端命令，然后将客户端连接放到全局等待写队列。
    - 写回结果：跟等待读队列处理类似，将等待写队列的客户端连接放入到全局等待读队列中，然后将等待读队列的客户端连接通过轮询调度算法分配给I/O线程处理，同时自己也会处理一个。当主线程处理完毕之后，会自旋等待I/O线程处理了完毕，然后清空队列。

<br>

- 为什么redis是单线程
    - redis是完全基于内存操作的，通常情况下CPU不会成为redis的瓶颈，redis的瓶颈最可能是机器内存的大小或网络带宽。既然CPU不会成为瓶颈，就使用单线程就好了，使用多线程会更复杂，同时需要引入上下文切换、加锁等等，会带来额外的性能消耗。单线程编程容易并且更容易维护。
    - 6.0版本对核心流程引入了多线程，主要用于解决redis在网络I/O上的性能瓶颈，而对核心命令的执行，还是单线程。

<br>

- Redis为什么使用单线程、单线程也很快
    - 基于内存的操作
    - 使用I/O多路复用模型，select，epoll等，基于reactor模式开发了自己的网络事件处理器
    - 单线程避免了不必要的上下文切换和竞争条件，减少了这方面的性能消耗。
    - 以上三点是主要原因，还有一些小优化，对数据结构进行了优化，简单动态字符串、压缩列表等。

<br>

- Redis在项目中的使用场景
    - 缓存、分布式锁、排行榜(zset)、计数(incrby)、消息队列(stream)、地理位置(geo)、访客统计(hyperloglog)等。

<br>

- Redis常见的数据结构
    - String、List、Hash、Set、Sorted Set：有序集合，Set的基础上加了个分值
    - Hyperloglog，通常用于基数统计。使用少量固定大小的内存，来统计集合中唯一的元素的数量。统计结果不是精确值，适用于对于统计结果精度要求不是特别高的场景，例如网站的UV统计。
    - Geo：可以将用户给定的地理位置信息存储起来，并对这些信息进行操作：获取2个位置的距离，根据给定地理位置坐标获取指定范围内的地理位置集合。
    - Bitmap：位图
    - Stream：主要用于消息队列，提供消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。

<br>

- Redis的字符串(SDS)和C语言的字符串的区别
    - 获取字符串长度的复杂度不同
        C语言获取长度的复杂度是O(n)，redis是O(1)
    - API安全级别不同
        C语言API是不安全的，可能会造成缓冲区溢出，SDS的API是安全的，不会造成缓冲区溢出
    - 修改字符串需要的内存重分配次数不同
        C语言修改字符串N次必须需要N次内存重分配，SDS最多需要N次内存重分配
    - 保存数据的格式不同
        C语言只能保存文本数据，SDS可以保存文本数据和二进制数据
    - 对于string.h库的使用不同
        C语言可以使用所有的库函数，SDS只能使用一部分库中的函数

<br>

- Sorted Set底层数据结构
    - Sorted Set(有序集合)：ziplist/skiplist
    - ziplist：使用压缩列表实现，当保存的元素都小于64字节，同时数量小于128时，使用该编码方式，否则使用skiplist。这两个参数可以通过zset-max-ziplist-enties、zset-max-ziplist-value来自定义修改。
    - skiplist：zset实现，一个zset同时包含一个字典和一个跳跃表。
<br>

- Sorted Set为什么同时使用字典和跳跃表
    - 主要是为了性能。
    - 单独使用字典：在执行范围内操作，如zrank、zrange，字典需要排序，至少需要O(nlogn)的时间复杂度和额外的O(N)的内存空间。
    - 单独使用跳跃表：根据成员查找分值操作的复杂度从O(1)上升为O(nlogn)。

<br>

- Sorted Set为什么使用跳跃表而不是红黑树
    - 跳跃表性能和红黑树差不多
    - 跳跃表更容易实现和调试

<br>

- Hash对象底层结构
    - Hash对象有两种编码：ziplist、hashtable
    - ziplist：使用压缩列表实现，每当有新的键值对加入到hash对象中时，会先将键的节点先压入压缩列表的表尾，接着将键的值压入压缩列表的表尾。这样的话保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后。先进的键值对被放到压缩列表的表头，后进的被放到表尾。
    - hashtable：使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值来保存。

<br>

- Hash对象的扩容流程
    - Hash对象在扩容的时候使用了一种叫渐进式rehash方式
    1. 计算新表size，掩码，为新表ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
    2. 将rehash索引计数器变量rehashidx的值设为0，表示rehash开始。
    3. 在rehash期间，每次对字典执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会出发额外的rehash操作。该方法会从ht[0]表的rehashidx索引位置上开始向后查找，找到第一个不为空的索引位置，然后将该索引位置上的所有节点rehash到ht[1]，当本次rehash工作完成之后，将ht[0]的rehashidx位置清空，同时将rehashidx属性的值加一。
    4. 将rehash分摊到每个操作上，redis除了文件事件外，还有时间事件，redis会定期触发时间事件，这些时间事件用于执行一些后台操作，其中就包括rehash操作；当redis发现有字典正在进行rehash操作时，会花费1毫秒的时候，帮助进行rehash。
    5. 随着操作的进行，当ht[0]的所有键值对都被rehash到ht[1]，此时rehash流程完成，会执行最后的清理工作：释放ht[0]的空间、将ht[0]指向ht[1]、重置ht[1]、重置rehashidx的值为-1。

<br>

- 渐进式rehash的优点
    - 采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。
    - 在渐进式rehash过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、更新、查找等操作会在两个哈希表中进行。
    - 在渐进式rehash期间，新增的键值对会被直接保存到ht[1]，ht[0]不再进行任何添加操作，这样就保证了ht[0]包含的键值对数量只减不增，并随着rehash操作的执行最终变成空表。

<br>

- rehash流程在数据量大的时候会有什么问题
    1. 扩容开始期间，会先给ht[1]分配空间，所以在整个扩容期间，会同时存在ht[0]和ht[1]，会占用额外的空间。
    2. 扩容期间同时存在ht[0]和ht[1]，查找、删除、更新操作等有概率同时操作两张表，耗时会增加。
    3. redis在内存使用接近maxmemory并且有设置驱逐策略的情况下，出现rehash会使得内存占用超过maxmemory，触发驱逐淘汰操作，导致maste/slave均有大量的key被驱逐淘汰，从而出现master/slave主从不一致。

<br>

- Redis的事件处理器
    - 由4部分组成：套接字、I/O多路复用程序、文件事件分派器以及事件处理器
    - 套接字：socket连接，也就是客户端连接。当一个套接字准备好执行连接、写入、读取、关闭等操作时，就会产生一个相应的文件事件。因为一个服务器可能连接多个套接字，所以多个文件事件有可能并发地出现。
    - I/O多路复用程序：提供select、epoll、evport、kqueue的实现，会根据当前系统自动选择最佳的方式。负责监听多个套接字，当套接字产生事件后，会向文件事件分派器传送那些产生了事件的套接字。
    - 当多个文件事件并发的出现时，I/O多路复用程序会将所有产生事件的套接字都放到一个队列里，然后通过这个队列有序、同步、每次以一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕后，才会继续传送下一个套接字。
    - 文件事件分派器：接收I/O多路复用程序传来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。
    - 事件处理器：就是一个个函数，定一个某个事件发生时，服务器应该执行的动作。例如：建立连接、命令查询、命令写入、连接关闭等。

<br>

- Redis删除过期键的策略(缓存失效策略、数据过期策略)
    - 定时删除：在设置键的过期事件的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存最友好，对cpu时间最不友好。
    - 惰性删除：每次获取键时，都会检查键是否过期，如果过期就删除键；如果没有过期就返回该键。对CPU时间最优化，对内存最不友好。
    - 定期删除：每个一段时间，默认100ms，程序就会对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少数据库由算法决定。前两种策略的折中，对cpu时间和内存的友好程度较平衡。
    - Redis使用惰性删除和定期删除。

<br>

- Redis的内存驱逐(淘汰)策略
    - 当redis的内存空间已经用满时，就会根据配置的驱逐策略，进行相应的动作
    - 有以下8中：
    1. 默认策略，不淘汰任何key，返回错误
    2. 在所有key中使用LRU算法淘汰部分key
    3. 在所有key中使用LFU算法淘汰部分key
    4. 在所有key中随机淘汰部分key
    5. 在设置了过期时间的key中，使用LRU算法淘汰部分key
    6. 在设置了过期时间的key中，使用LFU算法淘汰部分key
    7. 在设置了过期时间的key中，随机淘汰部分key
    8. 在设置了过期时间的key中，挑选TTL短的key淘汰

<br>

- 分片
    - 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面。
    - 最简单的分片方式就是范围分片，还是哈希分片，使用CRC32哈希函数将键转换成一个数字，再对实例数量求模就能知道应该存储的实例。
    - 根据执行分片的位置，可以分为三种分片方式：
    1. 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点
    2. 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
    3. 服务器分片：Redis Cluster
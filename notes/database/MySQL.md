# MySQL
- 数据类型
    - 字段类型
        - 整型
        - 浮点数
        - 字符串
        CHAR，VARCHAR
        VARCHAR这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行UPDATE时可能会使行变得比原来更长，当超过一个页所能容纳的大小时，就要执行额外的操作，MyISAM会将行拆分成不同的片段存储，而InnoDB则需要分裂页来使行放进页内。
        - 时间和日期
    - 选择优化的数据类型
    1. 更小的更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。
    2. 简单最好；例如，整型比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址。
    3. 尽量避免NULL；如果查询中包含可为NULL的列，对于MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值都比较都更复杂。
        - VARCHAR和CHAR
        字符串的最大长度比平均长度大很多；列更新的很少，所以碎片不是问题适合用VARCHAR
        CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。
<br>

- 存储引擎
    - InnoDB
        1. 是MySQL的默认存储引擎，只有在需要它不支持的特性时，才考虑使用其他的存储引擎。
        2. 实现了四个标准的隔离级别，默认级别是可重复读(RR)。在可重复读的隔离级别上，通过多版本并发控制(MVCC)+间隙锁(Next-key Locking)防止幻读。
        3. 主索引是聚簇索引，在索引中保存了数据，从而避免了直接读取磁盘，因此对查询性能有很大的提升。
        4. 内部做了很多优化，包括从磁盘读取数据是采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
        5. 支持真正的在线热备份。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。
    - MyISAM
        设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它，提供了大量的特性，包括压缩表、空间数据索引等。
    - 比较
        1. 事务：InnoDB是事务型的，可以使用commit和collback语句。
        2. 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。
        3. 外键：InnoDB支持外键。
        4. 备份：InnoDB支持在线热备份。
        5. 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度更慢。
        6. 其他：MyISAM支持压缩表和空间数据索引。
<br>

- 索引
    索引是帮助数据库高效获取数据的数据结构。索引是在存储引擎层面实现的，不是在服务器层实现的。
    常见的索引类型有：hash、b树、b+树
    - B+树
    B+树是基于B树和叶子节点顺序访问指针进行实现的，它具有B树的平衡性，而且通过顺序访问指针来提高区间查询的性能。
    进行查找操作时，首先在根结点进行二分查找，找到一个key对应的指针，直到找到叶子结点，然后在叶子结点上进行二分查找，找出key对应的data。插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作后，都需要对树进行一次分裂、合并、旋转等操作来维护平衡性。
        - 为什么不使用红黑树
        (1) 更少的查找次数。平衡树查找操作的时间复杂度等于树高，红黑树的树高明显比B+树的树高大很多，检索次数也就更多。
        (2) 利用计算机预读的特性。为了减少磁盘I/O，磁盘往往不是严格按需读取的，而是每次都会预读。预读过程中，磁盘进行顺序读取。操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以ye为单位进行交换数据。数据库会将索引的一个节点大小设置为页的大小，使得一个I/O就能完全存入一个节点，并且可以利用预读特性，相邻节点也能够被预先读入。
    - MySQL索引
        - B+树索引
            可以指定多个列作为索引列，多个索引列共同组成键。
            适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找，如果不是按照索引列的顺序进行查找，则无法使用索引。
            分为主索引和辅助索引。
            1. 主索引的叶子结点data域记录着完整的数据记录(聚簇索引)。因为无法把数据行存放在两个不同的地方，所以一个表只有一个索引。
            2. 辅助索引的叶子结点的data域记录着主键的值。使用辅助索引时，先找到主键值，然后再到主键值中进行查找。
        - 哈希索引
            哈希索引能够以O(1)时间进行查找，但是失去了有序性。无法用于排序分组；只支持精确查找，无法用于部分查找和范围查找。
            InnoDB中有一个自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+树索引之上在创建一个哈希索引，使之具有快速的哈希索引查找的优点。
    - 索引优化
        1. 独立的列：在进行查询的时候，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
        2. 多列索引：在需要使用多个列为条件进行查询时，使用多列索引比使用多个单列索引性能更好。
        3. 索引列的顺序：让选择性最强的索引列放在前面。索引的选择性是指不重复的索引值和记录总数的比值，也就是说索引的唯一性越强，重复的越少，越应该放在前面。
        4. 前缀索引：对于BLOB、TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。
        5. 覆盖索引：索引包含所有需要查询的字段的值。
    - 索引的优点
        - 大大减少了服务器需要扫描的数据行树
        - 帮助服务器避免进行排序和分组，也就是不需要创建临时表。(B+树是有序的，可以用于order by和group by操作。临时表主要用于排序和分组时创建。因为不需要排序和分组，所以不需要临时表)
        - 将随机I/O变为顺序I/O。(B+树索引是有序的，也就将相邻的数据都存储在一起。)
    - 索引使用的场景
        - 对于非常小的表，大部分的简单的扫描比建索引更有效。
        - 对于中到大型的表，索引就很有效。
        - 对于特大型的表，建立和维护索引的代价随之增加，一般会使用分区技术。
<br>

- 性能优化
    - 

<br>

- 分表分库
    - 水平切分 Sharding。当一个表的数据不断增加时，Sharding是必然的结果，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
    - 垂直切分 将一张表按列切分成多个表，通常是按照列的关系密集程度来切分，也可以将经常使用到的列和不经常使用到的列切分到不同的表中。
    - Sharding策略：哈希取模/范围/映射表：使用单独的一个数据库来存储映射关系。
    - Sharding存在的问题及解决方案
        - 事务问题：使用分布式事务来解决，如XA接口。
        - 链接：可以将原来的JOIN分解成多个单表查询，然后在用户程序中进行JOIN。
        - ID唯一性：(1)使用全局唯一ID：GUID。(2)为每个分片指定一个ID范围。(3)分布式ID生成器

<br>

- 主从复制与读写分离
    - 主从复制：主要涉及三个线程：binlog线程、I/O线程、SQL线程
        - binlog线程：负责将主服务器上的数据更改写入二进制日志中。
        - I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。
        - SQL线程：负责读取中继日志并重放其中的SQL语句。
    - 读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。
        - 读写分离能提高性能的原因在于
            - 主从服务器负责各自的读和写，极大程度缓解了锁的争用。
            - 从服务器可以使用MyISAM，提升查询性能以及节约系统开销。
            - 增加冗余，提高可靠性。
        读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

<br>

- 一条SQL的执行过程详解
    1. 首先系统与MySQL进行交互之前，MySQL驱动会帮我们建立好连接，然后我们将语句通过数据库连接池发送将一次请求发送到MySQL数据库中。
    2. MySQL中处理请求的线程在获取到请求以后获取SQL语句然后交给SQL接口去处理。
    3. 解析器将SQL语句解析成相应的语句，之后查询优化器根据成本(IO成本和CPU成本)最小原则来选择使用对应的索引，之后优化器调用存储引擎的接口去执行SQL。
    4. 执行器根据MySQL的查询计划，先是从缓存池中查询数据，如果没有就去数据库中查询，如果查询到了就将其放入到缓存池中。
    5. 在数据被缓存到缓存池的同时，会写入undo log日志文件。
    6. 更新的动作是在BufferPool中完成的，同时会将更新后的数据添加到redo log buffer中
    7. 完成以后就可以提交事务，在提交的同时(1)将redo log buffer中的数据刷入到redo log文件中。(2)将本次操作记录写入到bin log文件中。(3)将bin log文件名字和更新内容在bin log中的位置记录到redo log中，同时在redo log最后添加commit标记。

- BufferPool

- undo日志文件、redo日志文件和bin log日志文件
    - undo日志文件：记录数据修改前的样子，是逻辑擦耦走
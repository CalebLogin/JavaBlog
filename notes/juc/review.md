- 多线程出现要解决什么问题
为了平衡CPU、内存和IO设备之间的速度差异问题
原子性、可见性、有序性
- 多线程不安全的案例
多个线程对同一个数值进行加1，最终的结果可能小于总数
- 线程安全是不是非真即假? 不可变、绝对线程安全、相对线程安全、线程兼容、线程对立
- 线程安全的实现方法 互斥同步、非阻塞同步、无同步方案


- 线程有几种状态
- 线程的使用方式
- 基础线程机制
- synchronized和ReentrantLock的对比
  - 最主要的区别：一个基于jvm，一个基于api
  - s不可被中断，r可被中断
  - s实现非公平锁，r实现了公平锁和非公平锁
  - r可能绑定多个Condition对象



- synchronized实现加锁
  - 任意线程对object的访问都会去尝试获取object的监视器，如果获取不到就进入阻塞状态，当object的监视器占有者释放后，在同步队列中的线程就有机会获取该监视器
  - 保证可见性
- 锁的状态
  - 无锁001 -> 偏向锁101 -> 轻量级锁00 -> 重量级锁10

- 锁的优化
  - 自旋锁
  - 适应性自旋锁
  - 锁消除
  - 锁粗化


- volatile
- 可见性实现：内存屏障 / lock前缀的指令在多核处理器下会引发两件事情：将当前处理器缓存行中的数据写回到系统内存，写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效
- 禁止重排序
- 原子性：保证单次读写具有原子性


- 线程安全的实现方式：互斥同步，非阻塞同步，无同步方案
- CAS：compareAndSet
- AtomicStampReference解决CAS的ABA问题


- LockSupport
- park/unpark
- sleep和wait的区别：
  - s不会释放锁，w会释放锁
  - s必须传入时间，w可以不传入时间，不传入时间会一直阻塞下去，
  - s到了时间会自动唤醒，并且继续执行
- sleep和await的区别
  - await调用了LockSupport来实现当前线程的阻塞，阻塞当前线程之间干了两件事，将当前线程加入条件队列，完全释放锁，将state置为0，然后再调用park
- sleep和park的区别
  - s和p都是阻塞当前线程的执行，并且不会释放当前线程占有的资源
  - s没法外部唤醒，只能自己醒过来
  - s会抛出中断异常，p不需要捕获中断异常
  - sleep是一个native方法
  - park调用Unsafe的native方法
- wait和park的区别
  - w需要在synchronized块里执行，p可以在任意地方执行
  - w抛出中断异常，需要捕获，p不抛出中断异常
  - w不带超时的需要外部唤醒，不一定继续执行后续内容，p不带超时的需要外部唤醒，一定会继续执行后续内容
  - w之前执行了n会抛出异常，p之前抛出了u不会抛出异常
- park不会释放锁资源，释放锁资源实在await中实现的

- AQS
- 核心思想：如果被请求的共享资源空闲，则将当前线程设置为有效的工作线程，并将共享资源设定为锁定状态。如果不空闲，则需要一套线程阻塞等待以及被唤醒时的锁分配的机制，基于CLH队列锁实现的
- state：锁标志：1：canceled、0：表示在sync队列中，等待获取锁，-1：signal、-2：condition、-3：propagate
- 
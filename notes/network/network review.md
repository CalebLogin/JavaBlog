# 计算机网络面试

<!-- GFM-TOC -->
* [计算机网络](#计算机网络面试)
    * [计算机网络的五层架构](#计算机网络的五层架构)
    * [应用层](#应用层)
    * [传输层](#传输层)
    * [网络层](#网络层)
    * [数据链路层](#数据链路层)
    * [物理层](#物理层)


<!-- GFM-TOC -->

## 计算机网络的五层架构
- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层

## 应用层
- 常见使用TCP协议的应用服务：**HTTP、SMTP、POP3、FTP文本传送协议**
- 常见使用UDP协议的应用服务：**DHCP、NTP、TFTP**
- 同时使用TCP、UDP的应用服务：**SOCKS安全套接字协议、DNS地址解析协议**
#### DNS域名系统
- 分布式数据库，提供了IP地址和主机名之间相互转换的服务。
- 跟域名、顶级域名、二级域名
- 可以使用TCP或UDP协议，默认端口为`53`，大部分情况下使用UDP进行传输，当主机域名服务器向辅助域名服务器传送变化的那部分数据或者返回的响应超过512字节时，使用TCP传输。
#### FTP(文件传输协议)
#### DHCP(动态主机配置协议)
- 配置IP地址，子网掩码、网关IP地址
#### Web页面请求过程
1. **DHCP配置主机协议** 
当一台主机还没有分配IP地址时，主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的**UDP报文段**中。该报文段被放入一个具有广播IP目的地址和源IP目的地址的IP数据报中，该数据报被放置到MAC帧中，并广播到与交换机连接的所有设备。当与交换机相连的DHCP服务器收到广播帧后，将广播帧一层一层向上剖析，得到IP数据报、UDP报文段、DHCP请求报文，之后服务器生成DHCP ACK报文，**该报文包括IP地址、DNS服务器的IP地址、默认网关路由器的IP地址和子网掩码**。然后被放到UDP报文段中，接着放到IP数据报中，最后放入到MAC帧中。因为交换机具有自学习能力，交换机记录了MAC地址到其转发接口的交换机表项，因此这时候交换机知道应该向哪个端口进行转发。主机收到后，不断剖析得到DHCP报文，配置它的IP地址、子网掩码和DNS服务器的IP地址，并在IP转发表中安装默认网关。
2. **ARP解析MAC地址**
主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成套接字，需要知道网站的域名对应的IP地址。主机生成一个DNS查询报文，该DNS查询报文被放入目的地址为DNS服务器IP地址的IP数据报中。IP数据报被放入以太网帧中，该帧将被发送到网关路由器。DHCP过程中，只知道网关路由器的IP地址，不知道网关路由器的MAC地址，则主机生成一个包含网关路由器IP地址的ARP查询报文，被放入到一个具有广播目的地址的以太网帧中，并向交换机发送以太网帧，交换机收到以太网帧后转发给所有连接的设备，包括网关路由器。网关路由器在收到以太网帧后不断分解得到ARP查询报文，发现其中的IP地址与其接口的IP地址匹配，则生成ARP回答报文，包含了它的MAC地址，发送回主机。
3. **DNS域名解析**
主机在收到网关路由器发送回来的MAC地址后，就可以继续DNS解析过程了。当网关路由器收到主机的发送的包含DNS查询报文的以太网帧后，抽取出IP数据报，并决定该数据报应该发送给的路由器。到达DNS服务器之后，DNS解析得到DNS查询报文，在DNS数据库中查找出相应的记录后，发送DNS回答报文，把DNS查询报文放入UDP报文段中，接着放入IP数据报中，通过路由器反向转发回网关路由器，并通过以太网交换机达到主机。
4. **HTTP请求页面**
主机在得到IP地址后，生成TCP套接字，并向Web服务器发送Http Get报文。在生成套接字之前必须经过三次握手，在连接建立之后，浏览器生成HTTP GET 报文，并交付给HTTP服务器，HTTP服务器通过TCP套接字读取HTTP GET报文，生成一个HTTP响应报文，将Web页面放入报文主体中，发回给主机。浏览器收到HTTP响应报文，抽取出Web页面，之后进行渲染，显示Web页面。

#### HTTP / HTTPS
1. 长连接和短连接：Connection：keep-alive，1.1之前默认是短连接，之后默认是长连接

2. 状态码
    * 1xx：正在处理
    * 2xx：成功
    * 3xx：重定向码，需要进行附加操作以完成请求
    * 4xx：服务器无法处理请求
    * 5xx：服务器处理请求出错
3. SSL/TSL三次握手
    1. 客户端生成随机数，并且携带着版本号以及加密的方式发送给服务器，服务器判断是否可用支持的加密方式，如果版本号+加密方式可用，继续进行
    2. 服务端生成第二个随机数，携带者CA证书发送给客户端，客户端判断是否可用，可用继续进行
    3. 客户端生成第三个随机数，并将前两次的信息、摘要发送给服务端，服务端收到第三个随机数，并利用私钥进行解密，最后双方生成一个对话密钥。
4. Cookie、Session
    * HTTP是不保存状态的协议，不对请求和响应之间的通信状态进行保存
    * Session
        * 通过服务端记录用户的状态
        * 服务端通过创建一个特定的Session之后就可以标示这个用户，并跟踪这个用户
        * 服务端一般将Session保存在内存或数据库中(Redis)
        * 通过Cookie中附加一个Session ID来进行跟踪用户
    * Cookie
        * 都是用来跟踪浏览器用户身份的会话方式。
        * 一般用来保存用户的信息
        * 会话状态管理、个性化设置、浏览器行为跟踪
5. URI、URL
    * URL：统一资源定位符：是URI的子集
    * URI：统一资源标示符
6. HTTPS
    1. HTTP有安全问题：使用明文通信，内容可能被窃听。不验证通信方的身份，通信方的身份可能遭到伪装。无法证明报文的完整性，报文可能被篡改
    2. HTTPS：先让HTTP和SSL(Secure Sockets Layer)通信，SSL再和TCP通信，这样，HTTPS有了加密，认证和完整性保护
        * 加密：非对称加密方式进行通信：通信发送方在收到接收方的公开密钥之后，使用公开密钥对通信内容进行加密，接收方在收到通信内容后，用自己的私有密钥进行解密，得到通信内容
        * 认证：数字证书认证机构 (CA)，服务器运行人员向CA提出公开密钥的申请，CA在判明身份后，会对已签名的公开密钥对数字签名，然后分配这个已签名的公开密钥，与公开密钥证书绑定在一起。服务器会把证书发送给客户端，客户端在收到公开密钥后，先使用数字签名进行验证，如果验证成功就可以通信了。
        * 完整性保护：有了加密和认证这两个机制，就可以形成完整性保护

## 传输层

#### TCP的三次握手
A为客户端、B为服务端
- 首先B处于监听状态，等待客户端的连接
- A发送SYN=1，ACK=0的连接请求报文，选择一个初始序号x
- B收到请求连接报文，向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始序号y
- A收到B的连接确认报文后，向B发送确认报文，确认号为y+1，序号为x+1

##### 延迟ACK的原因
ACK是可以合并的，如果连续收到2个TCP包，只需要回复最终的ACK就可以了，可以降低网络流量。
如果接收方有数据要发送，就会放到发送数据的TCP包里，带上ACK信息，这样就避免了大量重复的ACK以单独的包发送，减少了网络流量。

##### 三次握手的原因
第三次握手是为了防止丢失的连接请求到达服务器，让服务器错误的打开连接。

客户端发送的连接请求如果因为网络问题在网络中滞留，这时客户端等待一个超时重传时间之后，会向服务器重新发送连接请求。如果这个滞留的请求最终到达服务器，如果没有第三次握手，服务器就会再次建立一个连接，存在第三次握手客户端就会忽略服务器之后发送的确认连接报文，不进行第二次第三次握手，这样连接就不会建立。


##### TCP三次握手的优化
<a href="https://zhuanlan.zhihu.com/p/198089844">参考链接</a>

**客户端的优化**
当客户端在等待服务端的ACK回复的时候，如果等待超时，则会重发SYN，重发次数默认为6次，第一次重发发生在1秒后，接下来的重发时间间隔以翻倍的方式增加，一共经历127秒后，才会终止三次握手。这时可以根据网络的稳定性和服务器的繁忙程度修改重试次数，调整三次握手的时间上限。比如在内网中通讯时，可以减少重发次数，尽快把错误暴露给客户端。
**服务端的优化**
在回复SYN+ACK时，服务器端会将未完成的握手信息放到半连接队列中，如果队列溢出SYN报文会丢失，导致连接失败，我们可以根据netstat -s 给出的统计信息判断队列长度是否合适，进而调整队列的长度。在收到ack时，服务器端会连接移入accept队列中，如果accept队列溢出，系统会丢弃ACK，可以通过netstat -s 给出的统计信息查看accept队列长度是否合适，可以适当调节队列的上限。

在服务器回复SYN+ACK时，若超时将重发SYN+ACK，网络稳定时SYN+ACK的重试次数可以降低。另外为了应付SYN泛洪攻击，应将tcp_syncookies的参数设为1，它在半连接队列满时，将开启syncookies功能，服务器根据状态计算出一个值，放在SYN+ACK的报文中，客户端在返回ACK时也会将该值返回，如果合法则认证建立成功。
**TFO绕过三次握手**
在首次连接建立时，客户端的SYN会明确告诉服务端自己想使用TFO功能，服务端在收到该请求后，会把客户端的ip地址用自己知道的密钥加密，作为Cookie携带在SYN+ACK中，客户端收到后会将Cookie保存到本地。当再次向服务端发送建立连接请求时，就可以在第一次SYN报文中携带数据，并附带Cookie，当服务端验证Cookie合法时，会直接建立成功，并把请求发给进程处理。


#### TCP四次挥手
- A发送释放报文，FIN=1
- B收到释放报文后，发出确认，此时TCP处于半关闭状态，B能向A发送数据，但是A不能向B发送数据
- 当B不再需要连接的时候，B发送释放报文，FIN=1
- A收到后发出确认，并进入TIME-WAIT状态，等待2MSL(最大报文存活时间)后释放连接
- B收到A的确认后释放连接。

##### 四次挥手的原因
客户端发出连接释放报文之后就入了CLOSED-WAIT状态，这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕后，服务器会发送FIN连接释放报文。

##### 为什么会有TIME-WAIT状态
客户端在收到服务端的FIN连接释放报文后，不会立刻进入CLOSED状态，而是会等待2MSL后再释放连接，理由如下：
- 确保客户端最后发出的确认报文能够到达服务端，如果没有到达服务端，服务端会重新发送连接释放请求报文，A等待时间就是为了防止这种事情发生。
- 为了让本次连接持续时间内产生的所有报文都在网络中消失，使得下一次新的连接不会产生旧的连接请求报文。(比如服务端在发送连接释放请求报文前，还发送了一次数据，结果这次数据在网络中滞留了，连接释放请求报文提前到达，为了不让这次滞留的数据出现在下一次新的连接中，要么等待接收它，要么等待这次请求数据死亡)。

#### TCP可靠传输
1. 应用程序被分割成TCP认为最合适发送的报文段
2. TCP对每个包进行编号，接收端对包进行排序，然后将有序的数据发送应用层
3. 校验和：TCP保持它的首部与所携带的数据的校验和，如果传输过程中数据发生变化，校验和会有差错，TCP将会丢弃该报文段
4. TCP丢弃重复的报文段
5. 流量控制：TCP连接的双方都会有一定的缓冲区，当接收方来不及处理发送方发来的数据时，会在返回确认的报文中携带能够容纳的数据的缓冲区大小，提示发送方降低发送的速率，防止包丢失。采用了滑动窗口协议。
6. 拥塞控制
7. ARQ协议：发完一个分组就停止发送，等待对方确认再接着发送。
8. 超时重传

#### TCP滑动窗口
TCP连接的双方都会有一定的缓冲区，发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口大小来告诉发送方自己的窗口大小，发送方根据这个值和其他信息来设计自己的窗口大小。

发送方窗口内的字节都允许被发送，接收方窗口内的字节都允许被接收。如果发送方的左部字节已经发送并得到了确认，发送方的窗口就向右滑动一段距离。接收方的左部字节已经发送确认并交付主机，就向右滑动一段距离。

接收方的滑动窗口只会对窗口内的最后一个按序到达的字节进行确认，比如收到字节为{31,33,34}，只会对31进行确认，发送方得到一个字节确认之后，就会知道该字节之前的字节都已经被接收。

#### TCP流量控制
流量控制是为了控制对方发送的速率，保证接收方来得及接收。

#### TCP拥塞控制
1. 拥塞窗口(cwnd)：状态变量
2. 慢开始和拥塞避免
发送的最初执行慢开始，cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd加倍。
由于慢开始到后面会使得cwnd增长的越来越快，会使得网络拥塞的可能性更高，所以设置一个ssthresh，当增长的cwnd>=ssthresh时，cwnd之后每次增长的次数变为1，当出现超时时，重新执行慢开始，ssthresh设为上次超时cwnd的一半。
3. 快重传和快恢复
快重传和快恢复是指cwnd的设定值，而不是cwnd的增长率，慢开始cwnd设定为1，快恢复的cwnd设定为ssthresh。
接收方只对窗口内最后一个有序到达的报文段进行确认，例如收到{31,33,34}，只会对31进行确认。当发送方连续收到三个重复确认，则判断下一个报文段丢失，立刻进行重传。在这种情况下，只是丢失个别报文段，不是出现拥塞，则会讲ssthresh设置为cwnd/2，cwnd=ssthresh，直接进入拥塞避免。

#### ARQ协议(自动重传请求)
##### 停止等待ARQ协议
- 每发完一个分组就停止发送，等到确认。如果过了一段时间还是没有收到ACK，则重新发送该分组。
- 在停止等待协议中，接收方收到了重复分组，会丢弃重复分组，但还是要发送ACK。

**优点：** 简单。
**缺点：** 信道利用率低，等待时间长。
**分三种情况：** (1)无差错情况 (2)出现差错情况 (3)确认丢失和确认迟到

##### 连续ARQ协议
- 发送方维护一个发送窗口，不需要等待接收方的ACK，发送方中发送窗口中的分组可以连续发送出去，采用累计确认的方式。

**优点** 信道利用率高，容易实现，即使确认丢失，也不必重传
**缺点** 接收方不能正确反映出已经正确接收的所有分组的信息。比如当第三个分组丢失时，接收方只返回前两个分组接收成功，这时发送方要发送第三个分组及之后的所有分组。


#### TCP与UDP的比较
1. TCP是面向连接的，可靠的的传输协议，有流量控制、拥塞控制，提供全双工通信、面向字节流(把应用层传下来的报文看成字节流，把字节流组织称大小不一的数据块)，点对点交互通信
2. UDP是无连接的，尽最大可能交付的，没有拥塞控制、面向报文(对应用程序传下来的报文不合并也不拆分，只添加UDP首部)，支持一对一、一对多、多对多的交互通信。
3. UDP首部8字节，包括源端口、目的端口、长度、检验和。12字节的伪首部：源IP地址、目的IP地址、0、17、UDP长度。
4. TCP首部20个字节
    **自己画图**

#### UDP实现可靠连接
1. 添加seq/ack机制，保证数据发送到对端
2. 添加发送和接收缓冲区，主要是用户超时重传
3. 添加超时重传机制

- 发送端发送数据时，随机生成一个seq=x.然后将每一片的按照数据大小分配seq。数据达到接收端后接收端发入缓存，并发送一个ack=x的包，当发送端收到ack后，删除缓冲区对应的数据。时间到后，定期检查任务是否需要超时重传数据。


## 网络层
#### IP协议


## 数据链路层


## 物理层

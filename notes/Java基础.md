# Java基础

## 为什么说java是编译和解释并存？
编译是指编译器是针对特定的操作系统将源码一次性翻译成可被平台执行的机器码。解释是指解释器对源码逐行解释成特定平台的机器码并立即执行。
java要先经过编译再经过解释两个步骤，由java编写的程序首先经过编译步骤，生成字节码文件，这种字节码文件必须由java解释器来解释执行。
## == 和 equal的区别？
== 对于普通类型来说是进行值的比较，对于引用类型来说是进行地址的比较。
equals 不能用于普通类型的比较，只能用来判断两个对象是否相等。对于没有重写equal的类，这时候equal和==的作用是相同的，比较的是两个对象的地址。对于覆盖了equal的类，比较的是equal方法中的，覆盖了equal方法，必须覆盖hashcode，hashcode的作用是获取哈希码，这个hash码的作用是确定该对象在哈希表中的位置，在使用hashset时，使用hashcode来确定对象加入的位置，如果发现有hashcode相同的对象，再调用equals来判断两个对象是否相等。如果两个对象相等，那么他们的hashcode一定是相等的。两个对象相等，对两个对象分别调用equals分别返回true。但是两个对象hashcode相等，他们也不一定是相等的。因此equals被覆盖过，hashcode也必须被覆盖。如果没有覆盖hashcode，这两个对象是不可能相等的，即使两个对象指向了相同的数据。
## 为什么java只有值传递没有引用传递？
值传递：方法调用得到的是调用者提供的值，引用传递：方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，但是不能修改传递值调用所对应的变量值。java总是按值调用，方法得到的是所有参数值的一个拷贝。
## 深拷贝和浅拷贝
浅拷贝：对于基本数据类型进行值传递，对于引用数据类型进行引用传递般的拷贝。
深拷贝：对于基本数据类型进行值传递，对于引用数据类型，创建一个新对象，并复制其内容。
## 重载和重写的区别？
重载就是同一个方法能够根据输入数据的不同，做出不同的处理。
重写是当子类继承父类的的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类的方法。方法的重写要遵循两同两小一大。两同：方法名相同，形参列表相同。两小：子类的返回类型要比父类的返回类型更小或相等。子类方法声明抛出的异常要比父类方法声明抛出的异常更小或相等。一大：子类方法的访问权限要比父类方法的访问权限更大或相等。
## 四个修饰符
1. public 
2. private
3. protected：包内调用和子类调用
4. 默认：包内调用

## abstract 和 interface
1. abstract：含有abstract修饰符的类即为抽象类。抽象类不能有实例对象。含有abstract的抽象方法的类必须声明为抽象类。抽象类中的方法不一定都是抽象方法。abstract类中的抽象方法必须在子类中实现，所有不能有抽象静态方法和抽象构造方法。如果子类中没有实现所有的abstract方法，子类也必须被声明为abstract类。接口可以说成是抽象类的一个特例，接口中的所有方法必须为抽象方法。接口中的成员方法定义为public abstract类型，所有的成员变量默认定义为public static final。
2. abstract和interface的区别：①接口中不能有构造方法，抽象类中可以有构造方法。②抽象类中可以有普通成员变量，接口中不可以有普通成员变量。③抽象类中可以包含非抽象的普通方法，接口中只能包含抽象方法，不能包含非抽象的普通方法。④抽象类中的抽象方法可以使public和protected，接口中的抽象方法只能是public的，默认是public abstract。⑤抽象类中可以有静态方法，接口中不能有静态方法。⑥抽象类中可以包含任意类型的静态成员变量，接口中只能包含public static final的静态成员变量，并且默认为public static final。⑦一个类可以实现多个接口，但只能继承一个类。
3. 接口更多的是在系统架构设计方面发挥作用，定义模块之间的通信契约。抽象类更多的是在代码实现方面发挥作用，可以实现代码复用。
4. 模板方法设计模式是抽象类的一个典型应用。
## 面向对象和面向过程的区别
面向过程：面向过程性能比较高。因为类调用时需要实例化，开销比较大，比较消耗资源，所有当性能是最重要的考量因素的时候。面向过程没有面向对象易维护、易复用、易扩展等。
面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态的特性，所有可以设计出低耦合的系统，是系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。
## 面向对象的三大特征？
封装
继承
多态
## 异常
异常分为error和exception。都继承Throwable。exception能被程序本身处理，而error不能被程序本身处理，只能尽量避免。
exception分为checkexception和uncheckexception。IOexception为checkexception，在编写代码的时候必须被捕获。而RuntimeException为uncheckexception，在编写代码的时候可以不被捕获。
受检查的异常：NullPointException、ClassCastException、NumberFormatException、ArrayOutOfBoundException、ArithmeticException。
受检查的异常：FileNotFoundException、SQLException。
## try catch finally
在以下三种特殊情况下finally不会被执行：System.exit()在finally之前。CPU关闭，线程死亡。
## 反射
1. 可以获取一个类的所有属性和方法，还可以调用这些属性和方法。
2. 缺点：让我们在运行时有了分析操作类的能力，同样增加了安全问题比如无视泛型参数的安全检查。
## 泛型
泛型提供了编译时类型检查机制，该机制允许程序员在编译时检测到非法类型。泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。
## 什么是序列化，什么是反序列化
如果我们需要持久化java对象必须把java对象保存到文件中或者在网络中传输java对象，都需要用到序列化。
1. 序列化：把数据结构或对象转换成二进制字节流的过程。
2. 反序列化：把二进制字节流转换成数据结构或对象的过程。
如果不想序列化可以使用transient关键字。transient只能修饰变量，不能修饰类和方法。在反序列化的过程中，被transient修饰的变量值会被置为类型的默认值。static变量属于类，不属于某个对象，所以不论是否被transient修饰，都不会被序列化。
## java中IO流分为几种？

## 既然有了字节流为什么还要字符流？
字符流是java虚拟机将字节转换得到的，这个过程是十分耗时的，如果我们不知道编码类型很容易出现乱码问题。所以IO流就直接提供了一个操作字符的接口，方便我们平时对字符进行流处理。对于音频，图片等媒体文字采用字节流比较合适，如果涉及到字符的话使用字符流比较好。
## socket套接字
套接字是网络编程中的一种通信机制，是支持TPC/IP的网络通信的基本操作单元，可以看做是不同主机的进程进行双向通信的端点。是通信双方的一种约定，用套接字的相关函数来完成通信过程。处于应用层和传输层之间。
## 设计模式